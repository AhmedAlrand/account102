
financial-management/
├── pom.xml
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── example/
│   │   │           └── financial/
│   │   │               ├── FinancialManagementApp.java
│   │   │               ├── CustomDashboardPane.java
│   │   │               ├── InvoicePane.java
│   │   │               ├── RecurringInvoicePane.java
│   │   │               ├── InventoryPane.java
│   │   │               ├── AttachmentPane.java
│   │   │               ├── ContactsPane.java
│   │   │               ├── ExpensesPane.java
│   │   │               ├── ReportPane.java
│   │   │               ├── AdjustmentsPane.java
│   │   │               ├── AuditTrailPane.java
│   │   │               ├── DatabaseService.java
│   │   │               ├── AuditService.java
│   │   │               ├── ExchangeRateService.java
│   │   │               ├── InvoiceDetails.java
│   │   │               ├── InvoiceLineItem.java
│   │   │               ├── InvoiceTemplate.java
│   │   │               ├── AsyncInvoicePdfService.java
│   │   │               ├── ErrorHandler.java
│   │   │               ├── NaturalLanguageParser.java
│   │   │               ├── DatabaseException.java
│   │   │               ├── DataProcessingException.java
│   │   │               ├── ValidationException.java
│   │   │               ├── InvoiceDiscussionThread.java
│   │   │               ├── InvoiceComment.java
│   │   │               ├── Contact.java
│   │   │               ├── InventoryItem.java
│   │   │               ├── Attachment.java
│   │   │               ├── Expense.java
│   │   │               ├── Adjustment.java
│   │   │               ├── AuditEntry.java
│   │   │               └── RecurringInvoice.java
│   │   └── resources/
│   │       ├── styles.css
│   │       ├── messages_en.properties
│   │       └── messages_ar.properties







//======================================================  pom.xml ================================




<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>financial-management</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <!-- JavaFX -->
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-controls</artifactId>
            <version>17</version>
        </dependency>
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-fxml</artifactId>
            <version>17</version>
        </dependency>
        <!-- Database -->
        <dependency>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
            <version>5.0.1</version>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <version>2.1.214</version>
        </dependency>
        <!-- JSON -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.12.5</version>
        </dependency>
        <!-- Logging -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>1.7.32</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-simple</artifactId>
            <version>1.7.32</version>
        </dependency>
        <!-- Analytics -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-math3</artifactId>
            <version>3.6.1</version>
        </dependency>
        <!-- PDF Generation -->
        <dependency>
            <groupId>com.itextpdf</groupId>
            <artifactId>itext7-core</artifactId>
            <version>7.2.5</version>
            <type>pom</type>
        </dependency>
        <!-- Caching -->
        <dependency>
            <groupId>com.github.ben-manes.caffeine</groupId>
            <artifactId>caffeine</artifactId>
            <version>3.0.5</version>
        </dependency>
        <!-- Trove for efficient collections -->
        <dependency>
            <groupId>net.sf.trove4j</groupId>
            <artifactId>trove4j</artifactId>
            <version>3.0.3</version>
        </dependency>
        <!-- Reactor for async -->
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-core</artifactId>
            <version>3.4.22</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <source>17</source>
                    <target>17</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.openjfx</groupId>
                <artifactId>javafx-maven-plugin</artifactId>
                <version>0.0.8</version>
                <configuration>
                    <mainClass>com.example.financial.FinancialManagementApp</mainClass>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

//============================================1 =======   FinancialManagementApp  ================================

package com.example.financial;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.stage.Stage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.Locale;
import java.util.ResourceBundle;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

public class FinancialManagementApp extends Application {
    private static final Logger LOGGER = LoggerFactory.getLogger(FinancialManagementApp.class);
    private static final int SCHEDULER_POOL_SIZE = 1;
    private static final long SCHEDULER_INTERVAL_MINUTES = 1440; // 1 day
    public static final ExecutorService executor = Executors.newFixedThreadPool(10);
    private ResourceBundle messages;
    private ScheduledExecutorService scheduler;
    private DatabaseService dbService;
    private AuditService auditService;
    private ExchangeRateService exchangeRateService;
    private String currentUser;
    private final AtomicBoolean isDisposed = new AtomicBoolean(false);
    private Label statusLabel;
    private ProgressBar progressBar;

    @Override
    public void start(Stage primaryStage) {
        dbService = new DatabaseService();
        auditService = new AuditService(dbService);
        exchangeRateService = new ExchangeRateService();
        currentUser = "user"; // Default for testing; replace with login logic later
        setLanguage("en");

        BorderPane root = new BorderPane();
        HBox topBar = createTopBar();
        TabPane tabPane = createTabPane();
        HBox statusBar = createStatusBar();

        root.setTop(topBar);
        root.setCenter(tabPane);
        root.setBottom(statusBar);

        Scene scene = new Scene(root, 1200, 900);
        scene.getStylesheets().add(getClass().getResource("/styles.css").toExternalForm());
        primaryStage.setTitle(messages.getString("title", "Financial Management"));
        primaryStage.setScene(scene);
        primaryStage.show();

        configureDatabase(primaryStage);
        startScheduledTasks();
    }

    private void setLanguage(String language) {
        try {
            messages = ResourceBundle.getBundle("messages", Locale.forLanguageTag(language));
        } catch (Exception e) {
            LOGGER.error("Error loading language properties for {}", language, e);
            messages = ResourceBundle.getBundle("messages", Locale.ENGLISH);
        }
        updateUIWithMessages();
    }

    private void updateUIWithMessages() {
        if (statusLabel != null) {
            statusLabel.setText(messages.getString("statusReady", "Ready"));
        }
        Stage stage = (Stage) statusLabel.getScene().getWindow();
        if (stage != null) {
            stage.setTitle(messages.getString("title", "Financial Management"));
        }
        TabPane tabPane = (TabPane) ((BorderPane) statusLabel.getScene().getRoot()).getCenter();
        if (tabPane != null) {
            tabPane.getTabs().get(0).setText(messages.getString("dashboard", "Dashboard"));
            tabPane.getTabs().get(1).setText(messages.getString("invoices", "Invoices"));
            tabPane.getTabs().get(2).setText(messages.getString("recurringInvoices", "Recurring Invoices"));
            tabPane.getTabs().get(3).setText(messages.getString("inventory", "Inventory"));
            tabPane.getTabs().get(4).setText(messages.getString("attachments", "Attachments"));
            tabPane.getTabs().get(5).setText(messages.getString("customersSuppliers", "Customers & Suppliers"));
            tabPane.getTabs().get(6).setText(messages.getString("expenses", "Expenses"));
            tabPane.getTabs().get(7).setText(messages.getString("reports", "Reports"));
            tabPane.getTabs().get(8).setText(messages.getString("adjustments", "Adjustments"));
            tabPane.getTabs().get(9).setText(messages.getString("auditTrail", "Audit Trail"));
        }
    }

    private void configureDatabase(Stage stage) {
        DatabaseConfigDialog configDialog = new DatabaseConfigDialog(stage, messages);
        configDialog.showAndWait();
        if (!configDialog.isConfirmed()) {
            stage.close();
        }
    }

    private HBox createTopBar() {
        HBox topBar = new HBox(10);
        topBar.setPadding(new javafx.geometry.Insets(5));

        ComboBox<String> themeCombo = new ComboBox<>();
        themeCombo.getItems().addAll("Light", "Dark");
        themeCombo.setValue("Light");
        themeCombo.setOnAction(e -> changeTheme(themeCombo.getValue()));
        topBar.getChildren().add(themeCombo);

        ComboBox<String> languageCombo = new ComboBox<>();
        languageCombo.getItems().addAll("English", "Arabic");
        languageCombo.setValue("English");
        languageCombo.setOnAction(e -> setLanguage(languageCombo.getValue().equals("English") ? "en" : "ar"));
        topBar.getChildren().add(languageCombo);

        Button newInvoiceButton = new Button(messages.getString("newInvoice", "New Invoice"));
        newInvoiceButton.setOnAction(e -> openNewInvoiceWindow());
        topBar.getChildren().add(newInvoiceButton);

        Button markPaymentButton = new Button(messages.getString("markPaymentReceived", "Mark Payment Received"));
        markPaymentButton.setOnAction(e -> markPaymentReceived());
        topBar.getChildren().add(markPaymentButton);

        MenuButton databaseMenuButton = new MenuButton(messages.getString("database", "Database"));
        MenuItem changeDbItem = new MenuItem(messages.getString("changeDatabase", "Change Database"));
        changeDbItem.setOnAction(e -> changeDatabase());
        MenuItem newDbItem = new MenuItem(messages.getString("newDatabase", "New Database"));
        newDbItem.setOnAction(e -> createNewDatabase());
        databaseMenuButton.getItems().addAll(changeDbItem, newDbItem);
        topBar.getChildren().add(databaseMenuButton);

        return topBar;
    }

    private TabPane createTabPane() {
    TabPane tabPane = new TabPane();
    tabPane.getTabs().addAll(
        new Tab(messages.getString("dashboard", "Dashboard"), new CustomDashboardPane(messages, dbService, auditService, exchangeRateService)),
        new Tab(messages.getString("invoices", "Invoices"), new InvoicePane(messages, dbService, auditService, exchangeRateService, false)),
        new Tab(messages.getString("recurringInvoices", "Recurring Invoices"), new RecurringInvoicePane(messages, dbService, auditService)),
        new Tab(messages.getString("inventory", "Inventory"), new InventoryPane(messages, dbService, auditService)),
        new Tab(messages.getString("attachments", "Attachments"), new AttachmentPane(messages, dbService, auditService)),
        new Tab(messages.getString("customersSuppliers", "Customers & Suppliers"), new ContactsPane(messages, dbService, auditService)),
        new Tab(messages.getString("expenses", "Expenses"), new ExpensesPane(messages, dbService, auditService)),
        new Tab(messages.getString("reports", "Reports"), new ReportPane(messages, dbService, auditService)), // Updated to ReportPane
        new Tab(messages.getString("adjustments", "Adjustments"), new AdjustmentsPane(messages, dbService, auditService)),
        new Tab(messages.getString("auditTrail", "Audit Trail"), new AuditTrailPane(messages, dbService, auditService))
    );
    tabPane.setTabClosingPolicy(TabPane.TabClosingPolicy.UNAVAILABLE);
    restrictAccessBasedOnRole(tabPane, currentUser);
    return tabPane;
}

    private HBox createStatusBar() {
        HBox statusBar = new HBox(10);
        statusBar.setPadding(new javafx.geometry.Insets(5));
        statusLabel = new Label(messages.getString("statusReady", "Ready"));
        progressBar = new ProgressBar();
        progressBar.setVisible(false);
        statusBar.getChildren().addAll(statusLabel, progressBar);
        return statusBar;
    }

    private void changeTheme(String theme) {
        Scene scene = statusLabel.getScene();
        scene.getStylesheets().clear();
        scene.getStylesheets().add(getClass().getResource("/styles.css").toExternalForm());
        if ("Dark".equals(theme)) {
            scene.getStylesheets().add(getClass().getResource("/dark-theme.css").toExternalForm());
        }
    }

    private void openNewInvoiceWindow() {
        Stage newStage = new Stage();
        newStage.setTitle(messages.getString("newInvoice", "New Invoice"));
        InvoicePane invoicePane = new InvoicePane(messages, dbService, auditService, exchangeRateService, true);
        Scene scene = new Scene(invoicePane, 800, 600);
        scene.getStylesheets().add(getClass().getResource("/styles.css").toExternalForm());
        newStage.setScene(scene);
        newStage.show();
    }

    private void markPaymentReceived() {
        TextInputDialog customerDialog = new TextInputDialog();
        customerDialog.setTitle("Mark Payment");
        customerDialog.setHeaderText(messages.getString("enterCustomerName", "Enter Customer Name"));
        customerDialog.showAndWait().ifPresent(customerName -> {
            Dialog<Void> paymentDialog = new Dialog<>();
            paymentDialog.setTitle("Enter General Payment");
            GridPane grid = new GridPane();
            grid.setHgap(10);
            grid.setVgap(10);

            TextField amountField = new TextField();
            ComboBox<String> currencyDropdown = new ComboBox<>();
            currencyDropdown.getItems().addAll("USD", "IQD", "RMB");
            currencyDropdown.setValue("USD");
            TextField exchangeRateField = new TextField("1.0");

            grid.add(new Label("Payment Amount:"), 0, 0);
            grid.add(amountField, 1, 0);
            grid.add(new Label("Currency:"), 0, 1);
            grid.add(currencyDropdown, 1, 1);
            grid.add(new Label("Exchange Rate (to USD):"), 0, 2);
            grid.add(exchangeRateField, 1, 2);

            paymentDialog.getDialogPane().setContent(grid);
            paymentDialog.getDialogPane().getButtonTypes().addAll(ButtonType.OK, ButtonType.CANCEL);

            paymentDialog.showAndWait().ifPresent(v -> {
                CompletableFuture.runAsync(() -> {
                    try {
                        double amount = Double.parseDouble(amountField.getText());
                        String currency = currencyDropdown.getValue();
                        double exchangeRate = Double.parseDouble(exchangeRateField.getText());
                        showProgress(true);
                        dbService.markPaymentReceived(customerName, amount, currency, exchangeRate, null);
                        auditService.logAction(currentUser, "payments", null, "General payment received: " + amount + " " + currency + " from " + customerName, null, null);
                        javafx.application.Platform.runLater(() -> new Alert(Alert.AlertType.INFORMATION, messages.getString("paymentReceived", "Payment Received: ") + amount + " " + currency + " from " + customerName).showAndWait());
                    } catch (Exception e) {
                        ErrorHandler.handleException(e, "Failed to mark payment", null);
                    } finally {
                        showProgress(false);
                    }
                }, executor);
            });
        });
    }

    private void changeDatabase() {
        DatabaseConfigDialog configDialog = new DatabaseConfigDialog((Stage) statusLabel.getScene().getWindow(), messages);
        configDialog.showAndWait();
        if (configDialog.isConfirmed()) {
            new Alert(Alert.AlertType.INFORMATION, messages.getString("dbConfigUpdated", "Database configuration updated")).showAndWait();
            dispose();
            launch();
        }
    }

    private void createNewDatabase() {
        TextInputDialog dbNameDialog = new TextInputDialog();
        dbNameDialog.setTitle("New Database");
        dbNameDialog.setHeaderText(messages.getString("enterNewDbName", "Enter New Database Name"));
        dbNameDialog.showAndWait().ifPresent(dbName -> {
            CompletableFuture.runAsync(() -> {
                try {
                    showProgress(true);
                    dbService.createNewDatabase(dbName);
                    auditService.logAction(currentUser, "databases", null, "Created new database: " + dbName, null, null);
                    javafx.application.Platform.runLater(() -> {
                        new Alert(Alert.AlertType.INFORMATION, messages.getString("dbCreated", "Database created: ") + dbName).showAndWait();
                        changeDatabase();
                    });
                } catch (DatabaseException e) {
                    ErrorHandler.handleException(e, messages.getString("errorCreatingDb", "Error creating database: ") + dbName, null);
                } finally {
                    showProgress(false);
                }
            }, executor);
        });
    }

    private void restrictAccessBasedOnRole(TabPane tabPane, String role) {
        if ("user".equals(role)) {
            tabPane.getTabs().get(8).setDisable(true); // Adjustments
            tabPane.getTabs().get(9).setDisable(true); // Audit Trail
        }
    }

    private void startScheduledTasks() {
        scheduler = Executors.newScheduledThreadPool(SCHEDULER_POOL_SIZE);
        scheduler.scheduleAtFixedRate(() -> {
            try {
                if (isDisposed.get()) return;
                showProgress(true);
                CompletableFuture.runAsync(() -> {
                    List<String> overduePayments = dbService.getOverduePayments(1, 100);
                    if (!overduePayments.isEmpty()) {
                        StringBuilder message = new StringBuilder(messages.getString("overduePayments", "Overdue Payments") + "\n");
                        overduePayments.forEach(payment -> message.append(payment).append("\n"));
                        javafx.application.Platform.runLater(() ->
                            new Alert(Alert.AlertType.WARNING, message.toString(), ButtonType.OK).showAndWait());
                    }
                    dbService.processRecurringInvoices();

                    List<String> reminders = dbService.getPendingReminders();
                    if (!reminders.isEmpty()) {
                        StringBuilder reminderMessage = new StringBuilder("Payment Reminders:\n");
                        reminders.forEach(reminder -> {
                            reminderMessage.append(reminder).append("\n");
                            String invoiceId = reminder.split(",")[0].split(":")[1].trim();
                            dbService.markReminderSent(invoiceId);
                        });
                        javafx.application.Platform.runLater(() ->
                            new Alert(Alert.AlertType.INFORMATION, reminderMessage.toString(), ButtonType.OK).showAndWait());
                    }
                    exchangeRateService.updateExchangeRates();
                }, executor).exceptionally(throwable -> {
                    LOGGER.error("Error in scheduled task", throwable);
                    return null;
                });
            } finally {
                showProgress(false);
            }
        }, 0, SCHEDULER_INTERVAL_MINUTES, TimeUnit.MINUTES);
    }

    private void showProgress(boolean show) {
        javafx.application.Platform.runLater(() -> {
            progressBar.setVisible(show);
            statusLabel.setText(show ? messages.getString("statusProcessing", "Processing...") : messages.getString("statusReady", "Ready"));
        });
    }

    @Override
    public void stop() {
        if (isDisposed.compareAndSet(false, true)) {
            try {
                if (scheduler != null && !scheduler.isShutdown()) scheduler.shutdownNow();
                if (executor != null && !executor.isShutdown()) executor.shutdownNow();
            } finally {
                dbService.close();
            }
        }
    }

    public static void main(String[] args) {
        launch(args);
    }
}

class DatabaseConfigDialog extends Dialog<Void> {
    private static final String DEFAULT_DB_URL = "jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1";
    private static final String DEFAULT_USERNAME = "sa";
    private TextField urlField, usernameField;
    private PasswordField passwordField;
    private boolean confirmed = false;
    private ResourceBundle messages;

    public DatabaseConfigDialog(Stage owner, ResourceBundle messages) {
        super();
        initOwner(owner);
        setTitle(messages.getString("dbConfigTitle", "Database Configuration"));
        this.messages = messages;
        initializeUI();
    }

    private void initializeUI() {
        GridPane grid = new GridPane();
        grid.setHgap(10);
        grid.setVgap(10);
        grid.setPadding(new javafx.geometry.Insets(10));

        grid.add(new Label(messages.getString("dbUrl", "Database URL:")), 0, 0);
        urlField = new TextField(DEFAULT_DB_URL);
        grid.add(urlField, 1, 0);

        grid.add(new Label(messages.getString("dbUsername", "Username:")), 0, 1);
        usernameField = new TextField(DEFAULT_USERNAME);
        grid.add(usernameField, 1, 1);

        grid.add(new Label(messages.getString("dbPassword", "Password:")), 0, 2);
        passwordField = new PasswordField();
        grid.add(passwordField, 1, 2);

        Button connectButton = new Button(messages.getString("connect", "Connect"));
        connectButton.setOnAction(e -> connect());
        grid.add(connectButton, 0, 3, 2, 1);

        getDialogPane().setContent(grid);
        getDialogPane().getButtonTypes().addAll(ButtonType.CANCEL);
    }

    private void connect() {
        String url = urlField.getText();
        String username = usernameField.getText();
        String password = passwordField.getText();
        try {
            if (url.isEmpty() || username.isEmpty() || password.isEmpty()) {
                throw new IllegalArgumentException("All fields are required");
            }
            confirmed = true;
            close();
        } catch (Exception e) {
            new Alert(Alert.AlertType.ERROR, "Invalid database configuration: " + e.getMessage()).showAndWait();
        }
    }

    public boolean isConfirmed() {
        return confirmed;
    }
}


//======================================= NEW ==========2========  CustomDashboardPane.java  ==============================================================

package com.example.financial;

import javafx.scene.control.*;
import javafx.scene.layout.*;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

public class CustomDashboardPane extends VBox {
    private final ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private final ExchangeRateService exchangeRateService;
    private Label totalSalesLabel, overdueAmountLabel, cashBalanceLabel, topCustomerLabel, totalTaxLabel;
    private ComboBox<String> timePeriodCombo;

    public CustomDashboardPane(ResourceBundle messages, DatabaseService dbService, AuditService auditService, ExchangeRateService exchangeRateService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        this.exchangeRateService = exchangeRateService;
        initializeUI();
        loadDashboardData("This Month");
    }

    private void initializeUI() {
        setSpacing(10);
        setPadding(new javafx.geometry.Insets(10));

        HBox controlBox = new HBox(10);
        controlBox.getChildren().add(new Label(messages.getString("timePeriod", "Time Period:")));
        timePeriodCombo = new ComboBox<>();
        timePeriodCombo.getItems().addAll("This Week", "This Month", "This Quarter", "This Year");
        timePeriodCombo.setValue("This Month");
        timePeriodCombo.setOnAction(e -> loadDashboardData(timePeriodCombo.getValue()));
        controlBox.getChildren().add(timePeriodCombo);

        GridPane metricsGrid = new GridPane();
        metricsGrid.setHgap(10);
        metricsGrid.setVgap(10);

        totalSalesLabel = new Label(messages.getString("totalSales", "Total Sales: ") + "0.00 USD");
        metricsGrid.add(totalSalesLabel, 0, 0);
        overdueAmountLabel = new Label(messages.getString("overdueAmount", "Overdue Amount: ") + "0.00 USD");
        metricsGrid.add(overdueAmountLabel, 1, 0);
        cashBalanceLabel = new Label(messages.getString("cashBalance", "Cash Balance: ") + "0.00 USD");
        metricsGrid.add(cashBalanceLabel, 0, 1);
        topCustomerLabel = new Label(messages.getString("topCustomer", "Top Customer: ") + "N/A");
        metricsGrid.add(topCustomerLabel, 1, 1);
        totalTaxLabel = new Label(messages.getString("totalTax", "Total Tax: ") + "0.00 USD");
        metricsGrid.add(totalTaxLabel, 0, 2);

        getChildren().addAll(controlBox, metricsGrid);
    }

    private void loadDashboardData(String period) {
        CompletableFuture.runAsync(() -> {
            try {
                String startDate, endDate;
                switch (period) {
                    case "This Week":
                        startDate = LocalDate.now().minusDays(7).toString();
                        endDate = LocalDate.now().toString();
                        break;
                    case "This Month":
                        startDate = LocalDate.now().withDayOfMonth(1).toString();
                        endDate = LocalDate.now().toString();
                        break;
                    case "This Quarter":
                        startDate = LocalDate.now().minusMonths(3).withDayOfMonth(1).toString();
                        endDate = LocalDate.now().toString();
                        break;
                    case "This Year":
                        startDate = LocalDate.now().withDayOfYear(1).toString();
                        endDate = LocalDate.now().toString();
                        break;
                    default:
                        startDate = endDate = LocalDate.now().toString();
                }

                double totalSales = dbService.getTotalSales();
                double overdueAmount = dbService.getOverdueAmount();
                double cashBalance = dbService.getCashBalance();
                Map<String, Double> salesByCustomer = dbService.getSalesByCustomer(startDate, endDate);
                Map<String, Double> taxReport = dbService.getTaxReport(startDate, endDate);

                String topCustomer = salesByCustomer.entrySet().stream()
                    .max(Map.Entry.comparingByValue())
                    .map(Map.Entry::getKey)
                    .orElse("N/A");
                double topCustomerSales = salesByCustomer.getOrDefault(topCustomer, 0.0);
                double totalTax = taxReport.getOrDefault("Total Taxes", 0.0);

                javafx.application.Platform.runLater(() -> {
                    totalSalesLabel.setText(messages.getString("totalSales", "Total Sales: ") + String.format("%.2f", totalSales) + " USD");
                    overdueAmountLabel.setText(messages.getString("overdueAmount", "Overdue Amount: ") + String.format("%.2f", overdueAmount) + " USD");
                    cashBalanceLabel.setText(messages.getString("cashBalance", "Cash Balance: ") + String.format("%.2f", cashBalance) + " USD");
                    topCustomerLabel.setText(messages.getString("topCustomer", "Top Customer: ") + topCustomer + " (" + String.format("%.2f", topCustomerSales) + " USD)");
                    totalTaxLabel.setText(messages.getString("totalTax", "Total Tax: ") + String.format("%.2f", totalTax) + " USD");
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, "Failed to load dashboard data", null);
            }
        }, FinancialManagementForm.executor);
    }
}

//========================================  NEW   ======== 3 ========  InvoicePane.java  ===============================================

package com.example.financial;

import com.fasterxml.jackson.databind.ObjectMapper;
import javafx.collections.FXCollections;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.*;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.CompletableFuture;

public class InvoicePane extends VBox {
    private static final ObjectMapper objectMapper = new ObjectMapper();
    private final ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private final ExchangeRateService exchangeRateService;
    private final boolean isNewInvoiceMode;
    private TextField invoiceIdField, customerNameField, customerContactField, customerEmailField, customerAddressField,
                      shippingChargeField, invoiceDiscountField, invoiceFixedDiscountField, invoiceTaxRateField,
                      totalAmountField, totalTaxField, paymentInstructionsField, notesField, logoPathField,
                      frequencyIntervalField;
    private ComboBox<String> customerDropdown, invoiceTypeDropdown, currencyDropdown, paymentCurrencyDropdown, paymentTermDropdown, statusDropdown,
                             frequencyTypeCombo;
    private DatePicker datePicker;
    private TableView<InvoiceLineItem> lineItemsTable;
    private CheckBox recurringCheckBox;
    private Spinner<Date> nextDateSpinner, endDateSpinner;
    private Map<String, TextField> customFieldInputs = new HashMap<>();

    public InvoicePane(ResourceBundle messages, DatabaseService dbService, AuditService auditService, ExchangeRateService exchangeRateService, boolean isNewInvoiceMode) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        this.exchangeRateService = exchangeRateService;
        this.isNewInvoiceMode = isNewInvoiceMode;
        initializeUI();
        if (!isNewInvoiceMode) loadInvoices();
    }

    private void initializeUI() {
        GridPane grid = new GridPane();
        grid.setHgap(10);
        grid.setVgap(10);
        grid.setPadding(new javafx.geometry.Insets(10));

        // Invoice Details
        grid.add(new Label(messages.getString("invoiceId", "Invoice ID:")), 0, 0);
        invoiceIdField = new TextField();
        invoiceIdField.setEditable(false);
        grid.add(invoiceIdField, 1, 0);

        grid.add(new Label(messages.getString("invoiceType", "Invoice Type:")), 0, 1);
        invoiceTypeDropdown = new ComboBox<>(FXCollections.observableArrayList("Sale", "Purchase", "Import", "Sale Return", "Purchase Return"));
        invoiceTypeDropdown.setValue("Sale");
        grid.add(invoiceTypeDropdown, 1, 1);

        grid.add(new Label(messages.getString("customer", "Customer:")), 0, 2);
        customerDropdown = new ComboBox<>();
        customerDropdown.setOnAction(e -> populateCustomerFields());
        grid.add(customerDropdown, 1, 2);

        grid.add(new Label(messages.getString("customerName", "Name:")), 0, 3);
        customerNameField = new TextField();
        grid.add(customerNameField, 1, 3);

        grid.add(new Label(messages.getString("customerContact", "Contact:")), 0, 4);
        customerContactField = new TextField();
        grid.add(customerContactField, 1, 4);

        grid.add(new Label(messages.getString("customerEmail", "Email:")), 0, 5);
        customerEmailField = new TextField();
        grid.add(customerEmailField, 1, 5);

        grid.add(new Label(messages.getString("customerAddress", "Address:")), 0, 6);
        customerAddressField = new TextField();
        grid.add(customerAddressField, 1, 6);

        grid.add(new Label(messages.getString("date", "Date:")), 0, 7);
        datePicker = new DatePicker();
        datePicker.setValue(java.time.LocalDate.of(2025, 2, 26));
        grid.add(datePicker, 1, 7);

        grid.add(new Label(messages.getString("currency", "Currency:")), 0, 8);
        currencyDropdown = new ComboBox<>(FXCollections.observableArrayList("USD", "IQD", "RMB"));
        currencyDropdown.setValue("USD");
        currencyDropdown.setOnAction(e -> updateExchangeRate());
        grid.add(currencyDropdown, 1, 8);

        grid.add(new Label(messages.getString("paymentCurrency", "Payment Currency:")), 0, 9);
        paymentCurrencyDropdown = new ComboBox<>(FXCollections.observableArrayList("USD", "IQD", "RMB"));
        paymentCurrencyDropdown.setValue("USD");
        grid.add(paymentCurrencyDropdown, 1, 9);

        grid.add(new Label(messages.getString("paymentTerm", "Payment Term:")), 0, 10);
        paymentTermDropdown = new ComboBox<>(FXCollections.observableArrayList("Net 15", "Net 30", "Net 60", "Due on Receipt", "Custom"));
        paymentTermDropdown.setValue("Net 30");
        paymentTermDropdown.setOnAction(e -> handleCustomPaymentTerm());
        grid.add(paymentTermDropdown, 1, 10);

        grid.add(new Label(messages.getString("paymentInstructions", "Payment Instructions:")), 0, 11);
        paymentInstructionsField = new TextField("Please pay within 30 days.");
        grid.add(paymentInstructionsField, 1, 11);

        grid.add(new Label(messages.getString("status", "Status:")), 0, 12);
        statusDropdown = new ComboBox<>(FXCollections.observableArrayList("DRAFT", "SENT", "VIEWED", "PAID", "OVERDUE"));
        statusDropdown.setValue("DRAFT");
        grid.add(statusDropdown, 1, 12);

        // Line Items Table
        lineItemsTable = new TableView<>();
        TableColumn<InvoiceLineItem, Integer> productIdCol = new TableColumn<>("Product ID");
        productIdCol.setCellValueFactory(new PropertyValueFactory<>("productId"));
        TableColumn<InvoiceLineItem, Integer> warehouseIdCol = new TableColumn<>("Warehouse ID");
        warehouseIdCol.setCellValueFactory(new PropertyValueFactory<>("warehouseId"));
        TableColumn<InvoiceLineItem, Integer> quantityCol = new TableColumn<>("Quantity");
        quantityCol.setCellValueFactory(new PropertyValueFactory<>("quantity"));
        TableColumn<InvoiceLineItem, String> unitCol = new TableColumn<>("Unit");
        unitCol.setCellValueFactory(new PropertyValueFactory<>("unit"));
        TableColumn<InvoiceLineItem, Double> unitPriceCol = new TableColumn<>("Unit Price");
        unitPriceCol.setCellValueFactory(new PropertyValueFactory<>("unitPrice"));
        TableColumn<InvoiceLineItem, Double> totalPriceCol = new TableColumn<>("Total Price");
        totalPriceCol.setCellValueFactory(new PropertyValueFactory<>("totalPrice"));
        TableColumn<InvoiceLineItem, Double> discountCol = new TableColumn<>("Discount (%)");
        discountCol.setCellValueFactory(new PropertyValueFactory<>("discount"));
        TableColumn<InvoiceLineItem, Double> fixedDiscountCol = new TableColumn<>("Fixed Discount");
        fixedDiscountCol.setCellValueFactory(new PropertyValueFactory<>("fixedDiscount"));
        TableColumn<InvoiceLineItem, Double> taxRateCol = new TableColumn<>("Tax Rate (%)");
        taxRateCol.setCellValueFactory(new PropertyValueFactory<>("taxRate"));
        TableColumn<InvoiceLineItem, Double> totalTaxCol = new TableColumn<>("Total Tax");
        totalTaxCol.setCellValueFactory(new PropertyValueFactory<>("totalTax"));
        TableColumn<InvoiceLineItem, String> currencyCol = new TableColumn<>("Currency");
        currencyCol.setCellValueFactory(new PropertyValueFactory<>("currency"));

        lineItemsTable.getColumns().addAll(productIdCol, warehouseIdCol, quantityCol, unitCol, unitPriceCol, totalPriceCol,
            discountCol, fixedDiscountCol, taxRateCol, totalTaxCol, currencyCol);
        lineItemsTable.setPrefHeight(200);

        // Totals
        grid.add(new Label(messages.getString("shippingCharge", "Shipping Charge:")), 0, 13);
        shippingChargeField = new TextField("0.0");
        shippingChargeField.textProperty().addListener((obs, oldVal, newVal) -> updateTotalAmounts());
        grid.add(shippingChargeField, 1, 13);

        grid.add(new Label(messages.getString("invoiceDiscount", "Invoice Discount (%):")), 0, 14);
        invoiceDiscountField = new TextField("0.0");
        invoiceDiscountField.textProperty().addListener((obs, oldVal, newVal) -> updateTotalAmounts());
        grid.add(invoiceDiscountField, 1, 14);

        grid.add(new Label(messages.getString("invoiceFixedDiscount", "Fixed Discount:")), 0, 15);
        invoiceFixedDiscountField = new TextField("0.0");
        invoiceFixedDiscountField.textProperty().addListener((obs, oldVal, newVal) -> updateTotalAmounts());
        grid.add(invoiceFixedDiscountField, 1, 15);

        grid.add(new Label(messages.getString("invoiceTaxRate", "Invoice Tax Rate (%):")), 0, 16);
        invoiceTaxRateField = new TextField("0.0");
        invoiceTaxRateField.textProperty().addListener((obs, oldVal, newVal) -> updateTotalAmounts());
        grid.add(invoiceTaxRateField, 1, 16);

        grid.add(new Label(messages.getString("totalTax", "Total Tax:")), 0, 17);
        totalTaxField = new TextField("0.0");
        totalTaxField.setEditable(false);
        grid.add(totalTaxField, 1, 17);

        grid.add(new Label(messages.getString("totalAmount", "Total Amount:")), 0, 18);
        totalAmountField = new TextField("0.0");
        totalAmountField.setEditable(false);
        grid.add(totalAmountField, 1, 18);

        // Buttons
        HBox buttonBox = new HBox(10);
        Button saveButton = new Button(messages.getString("save", "Save"));
        saveButton.setOnAction(e -> saveInvoice());
        Button addLineItemButton = new Button(messages.getString("addLineItem", "Add Line Item"));
        addLineItemButton.setOnAction(e -> addLineItem());
        buttonBox.getChildren().addAll(saveButton, addLineItemButton);

        getChildren().addAll(grid, lineItemsTable, buttonBox);

        CompletableFuture.runAsync(() -> {
            try {
                List<Contact> customers = dbService.getCustomers(1, 100);
                javafx.application.Platform.runLater(() -> {
                    customerDropdown.getItems().addAll(customers.stream().map(c -> c.getId() + " - " + c.getName()).toList());
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, "Failed to load customers", null);
            }
        }, FinancialManagementForm.executor);

        updateTotalAmounts();
    }

    private void populateCustomerFields() {
        String selectedCustomer = customerDropdown.getValue();
        if (selectedCustomer != null) {
            try {
                int customerId = Integer.parseInt(selectedCustomer.split(" - ")[0]);
                List<Contact> customers = dbService.getCustomers(1, 100);
                Contact customer = customers.stream().filter(c -> c.getId() == customerId).findFirst().orElse(null);
                if (customer != null) {
                    customerNameField.setText(customer.getName());
                    customerContactField.setText(customer.getContact());
                    customerEmailField.setText(customer.getEmail());
                    customerAddressField.setText(customer.getAddress());
                    String typicalTerms = dbService.getTypicalPaymentTerms(customerId);
                    if (typicalTerms != null) paymentInstructionsField.setText(typicalTerms);
                }
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, "Failed to populate customer fields", null);
            }
        }
    }

    private void handleCustomPaymentTerm() {
        if ("Custom".equals(paymentTermDropdown.getValue())) {
            TextInputDialog dialog = new TextInputDialog();
            dialog.setTitle("Custom Payment Term");
            dialog.setHeaderText("Enter custom payment term:");
            dialog.showAndWait().ifPresent(paymentInstructionsField::setText);
        }
    }

    private void updateExchangeRate() {
        String fromCurrency = currencyDropdown.getValue();
        String toCurrency = "USD";
        CompletableFuture.runAsync(() -> {
            try {
                double rate = exchangeRateService.getExchangeRate(fromCurrency, toCurrency);
                javafx.application.Platform.runLater(this::updateTotalAmounts);
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, "Failed to update exchange rate", null);
            }
        }, FinancialManagementForm.executor);
    }

    private void saveInvoice() {
        CompletableFuture.runAsync(() -> {
            try {
                String invoiceId = invoiceIdField.getText();
                Integer customerId = customerDropdown.getValue() != null ?
                    Integer.parseInt(customerDropdown.getValue().split(" - ")[0]) : null;
                String invoiceType = invoiceTypeDropdown.getValue();
                String date = datePicker.getValue().toString();
                double shippingCharge = Double.parseDouble(shippingChargeField.getText());
                double invoiceDiscount = Double.parseDouble(invoiceDiscountField.getText());
                double invoiceFixedDiscount = Double.parseDouble(invoiceFixedDiscountField.getText());
                double invoiceTaxRate = Double.parseDouble(invoiceTaxRateField.getText());
                double totalAmount = Double.parseDouble(totalAmountField.getText());
                double totalTax = Double.parseDouble(totalTaxField.getText());
                String currency = currencyDropdown.getValue();
                String paymentCurrency = paymentCurrencyDropdown.getValue();
                String paymentInstructions = paymentInstructionsField.getText();
                String paymentTerm = paymentTermDropdown.getValue();
                String status = statusDropdown.getValue();
                String notes = notesField.getText();
                String logoPath = logoPathField.getText();
                double exchangeRate = exchangeRateService.getExchangeRate(currency, "USD");
                List<InvoiceLineItem> lineItems = new ArrayList<>(lineItemsTable.getItems());

                Map<String, String> customFields = new HashMap<>();

                if (customerId != null && !customerNameField.getText().isEmpty()) {
                    dbService.updateCustomer(customerId, customerNameField.getText(), customerContactField.getText(),
                        customerEmailField.getText(), customerAddressField.getText());
                }

                String customerLocation = customerAddressField.getText().split(",")[1].trim();
                for (int i = 0; i < lineItems.size(); i++) {
                    InvoiceLineItem item = lineItems.get(i);
                    DatabaseService.Product product = dbService.getProductCache().get(item.getProductId());
                    double taxRate = dbService.getTaxRate(customerLocation, product.getTaxCode());
                    double totalPrice = item.getTotalPrice();
                    double totalTaxItem = totalPrice * (taxRate / 100);
                    lineItems.set(i, new InvoiceLineItem(item.getId(), item.getProductId(), item.getWarehouseId(), item.getQuantity(),
                        item.getUnit(), item.getUnitPrice(), totalPrice, 0.0, 0.0, item.getDiscount(), item.getFixedDiscount(),
                        taxRate, totalTaxItem, item.getCurrency()));
                }
                updateTotalAmounts();

                if (invoiceId.isEmpty() || isNewInvoiceMode) {
                    dbService.saveInvoice(customerId, invoiceType, date, totalAmount, totalTax, currency, lineItems, null,
                        paymentCurrency, paymentInstructions, paymentTerm, status, notes, exchangeRate, invoiceDiscount,
                        invoiceFixedDiscount, invoiceTaxRate, shippingCharge, logoPath, customFields);
                    auditService.logAction("user", "invoices", null, "Created invoice: " + invoiceType, null, null);
                } else {
                    dbService.updateInvoice(invoiceId, customerId, invoiceType, date, totalAmount, totalTax, currency, lineItems,
                        paymentCurrency, paymentInstructions, paymentTerm, status, notes, exchangeRate, invoiceDiscount,
                        invoiceFixedDiscount, invoiceTaxRate, shippingCharge, logoPath, customFields);
                    auditService.logAction("user", "invoices", invoiceId, "Updated invoice", null, null);
                }

                javafx.application.Platform.runLater(() -> {
                    new Alert(Alert.AlertType.INFORMATION, messages.getString("invoiceSaved", "Invoice Saved")).showAndWait();
                    if (isNewInvoiceMode) ((Stage) getScene().getWindow()).close();
                    else loadInvoices();
                });
            } catch (Exception e) {
                ErrorHandler.handleException(e, "Failed to save invoice", null);
            }
        }, FinancialManagementForm.executor);
    }

    private void addLineItem() {
        Dialog<InvoiceLineItem> dialog = new Dialog<>();
        dialog.setTitle("Add Line Item");
        GridPane dialogPane = new GridPane();
        dialogPane.setHgap(10);
        dialogPane.setVgap(10);

        TextField productIdField = new TextField();
        TextField warehouseIdField = new TextField();
        TextField quantityField = new TextField();
        TextField unitField = new TextField();
        TextField unitPriceField = new TextField();
        TextField discountField = new TextField("0.0");
        TextField fixedDiscountField = new TextField("0.0");
        TextField taxRateField = new TextField("0.0");
        ComboBox<String> currencyCombo = new ComboBox<>(FXCollections.observableArrayList("USD", "IQD", "RMB"));
        currencyCombo.setValue(currencyDropdown.getValue());

        dialogPane.add(new Label("Product ID:"), 0, 0); dialogPane.add(productIdField, 1, 0);
        dialogPane.add(new Label("Warehouse ID:"), 0, 1); dialogPane.add(warehouseIdField, 1, 1);
        dialogPane.add(new Label("Quantity:"), 0, 2); dialogPane.add(quantityField, 1, 2);
        dialogPane.add(new Label("Unit:"), 0, 3); dialogPane.add(unitField, 1, 3);
        dialogPane.add(new Label("Unit Price:"), 0, 4); dialogPane.add(unitPriceField, 1, 4);
        dialogPane.add(new Label("Discount (%):"), 0, 5); dialogPane.add(discountField, 1, 5);
        dialogPane.add(new Label("Fixed Discount:"), 0, 6); dialogPane.add(fixedDiscountField, 1, 6);
        dialogPane.add(new Label("Tax Rate (%):"), 0, 7); dialogPane.add(taxRateField, 1, 7);
        dialogPane.add(new Label("Currency:"), 0, 8); dialogPane.add(currencyCombo, 1, 8);

        dialog.getDialogPane().setContent(dialogPane);
        dialog.getDialogPane().getButtonTypes().addAll(ButtonType.OK, ButtonType.CANCEL);

        dialog.setResultConverter(dialogButton -> {
            if (dialogButton == ButtonType.OK) {
                try {
                    int productId = Integer.parseInt(productIdField.getText());
                    int warehouseId = Integer.parseInt(warehouseIdField.getText());
                    int quantity = Integer.parseInt(quantityField.getText());
                    String unit = unitField.getText();
                    double unitPrice = Double.parseDouble(unitPriceField.getText());
                    double discount = Double.parseDouble(discountField.getText());
                    double fixedDiscount = Double.parseDouble(fixedDiscountField.getText());
                    double taxRate = Double.parseDouble(taxRateField.getText());
                    String currency = currencyCombo.getValue();
                    double discountedPrice = unitPrice * (1 - discount / 100) - fixedDiscount;
                    double totalPrice = discountedPrice * quantity;
                    double totalTax = totalPrice * (taxRate / 100);

                    return new InvoiceLineItem(0, productId, warehouseId, quantity, unit, unitPrice, totalPrice, 0.0, 0.0, discount, fixedDiscount, taxRate, totalTax, currency);
                } catch (NumberFormatException e) {
                    ErrorHandler.handleException(e, "Invalid input for line item", null);
                    return null;
                }
            }
            return null;
        });

        dialog.showAndWait().ifPresent(item -> {
            lineItemsTable.getItems().add(item);
            updateTotalAmounts();
        });
    }

    private void updateTotalAmounts() {
        double total = 0.0;
        double totalTax = 0.0;
        for (InvoiceLineItem item : lineItemsTable.getItems()) {
            total += item.getTotalPrice();
            totalTax += item.getTotalTax();
        }
        double invoiceDiscount = parseDoubleSafely(invoiceDiscountField.getText());
        double invoiceFixedDiscount = parseDoubleSafely(invoiceFixedDiscountField.getText());
        double invoiceTaxRate = parseDoubleSafely(invoiceTaxRateField.getText());
        double shippingCharge = parseDoubleSafely(shippingChargeField.getText());
        double discountedTotal = total * (1 - invoiceDiscount / 100) - invoiceFixedDiscount;
        double invoiceLevelTax = discountedTotal * (invoiceTaxRate / 100);
        total = discountedTotal + invoiceLevelTax + shippingCharge;
        totalTax += invoiceLevelTax;

        totalAmountField.setText(String.format("%.2f", total));
        totalTaxField.setText(String.format("%.2f", totalTax));
    }

    private double parseDoubleSafely(String value) {
        try {
            return Double.parseDouble(value);
        } catch (NumberFormatException e) {
            return 0.0;
        }
    }

    private void loadInvoices() {
        CompletableFuture.runAsync(() -> {
            try {
                List<InvoiceDetails> invoices = dbService.searchInvoices("");
                if (!invoices.isEmpty()) {
                    InvoiceDetails firstInvoice = invoices.get(0);
                    javafx.application.Platform.runLater(() -> {
                        invoiceIdField.setText(firstInvoice.getInvoiceId());
                        customerDropdown.setValue(firstInvoice.getCustomerName() != null ?
                            dbService.getCustomerCache().getKey(firstInvoice.getCustomerName()) + " - " + firstInvoice.getCustomerName() : null);
                        populateCustomerFields();
                        invoiceTypeDropdown.setValue(firstInvoice.getInvoiceType());
                        datePicker.setValue(java.time.LocalDate.parse(firstInvoice.getDate()));
                        totalAmountField.setText(String.format("%.2f", firstInvoice.getTotalAmount()));
                        totalTaxField.setText(String.format("%.2f", firstInvoice.getTotalTax()));
                        currencyDropdown.setValue(firstInvoice.getCurrency());
                        paymentCurrencyDropdown.setValue(firstInvoice.getPaymentCurrency());
                        paymentInstructionsField.setText(firstInvoice.getPaymentInstructions());
                        paymentTermDropdown.setValue(firstInvoice.getPaymentTerm());
                        statusDropdown.setValue(firstInvoice.getStatus());
                        lineItemsTable.getItems().clear();
                        lineItemsTable.getItems().addAll(firstInvoice.getLineItems());
                    });
                }
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, "Failed to load invoices", null);
            }
        }, FinancialManagementForm.executor);
    }
}



//=================4============= src/main/java/com/example/financial/RecurringInvoicePane.java =================




package com.example.financial;

import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.concurrent.CompletableFuture;

public class RecurringInvoicePane extends VBox {
    private final ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private TableView<RecurringInvoice> recurringTable;
    private TextField invoiceIdField, frequencyIntervalField;
    private ComboBox<String> frequencyTypeCombo;
    private Spinner<Date> nextDateSpinner, endDateSpinner;

    public RecurringInvoicePane(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
        loadRecurringInvoices();
    }

    private void initializeUI() {
        setSpacing(10);
        setPadding(new javafx.geometry.Insets(10));

        recurringTable = new TableView<>();
        TableColumn<RecurringInvoice, Integer> idCol = new TableColumn<>("ID");
        idCol.setCellValueFactory(new PropertyValueFactory<>("id"));
        TableColumn<RecurringInvoice, String> invoiceIdCol = new TableColumn<>("Invoice ID");
        invoiceIdCol.setCellValueFactory(new PropertyValueFactory<>("invoiceId"));
        TableColumn<RecurringInvoice, String> frequencyCol = new TableColumn<>("Frequency");
        frequencyCol.setCellValueFactory(new PropertyValueFactory<>("frequencyType"));
        TableColumn<RecurringInvoice, Integer> intervalCol = new TableColumn<>("Interval");
        intervalCol.setCellValueFactory(new PropertyValueFactory<>("frequencyInterval"));
        TableColumn<RecurringInvoice, String> nextDateCol = new TableColumn<>("Next Date");
        nextDateCol.setCellValueFactory(new PropertyValueFactory<>("nextDate"));
        TableColumn<RecurringInvoice, String> endDateCol = new TableColumn<>("End Date");
        endDateCol.setCellValueFactory(new PropertyValueFactory<>("endDate"));
        TableColumn<RecurringInvoice, String> lastGeneratedCol = new TableColumn<>("Last Generated");
        lastGeneratedCol.setCellValueFactory(new PropertyValueFactory<>("lastGenerated"));
        recurringTable.getColumns().addAll(idCol, invoiceIdCol, frequencyCol, intervalCol, nextDateCol, endDateCol, lastGeneratedCol);
        recurringTable.setPrefHeight(300);

        GridPane inputGrid = new GridPane();
        inputGrid.setHgap(10);
        inputGrid.setVgap(10);

        inputGrid.add(new Label(messages.getString("invoiceId", "Invoice ID:")), 0, 0);
        invoiceIdField = new TextField();
        inputGrid.add(invoiceIdField, 1, 0);

        inputGrid.add(new Label(messages.getString("frequencyType", "Frequency Type:")), 0, 1);
        frequencyTypeCombo = new ComboBox<>();
        frequencyTypeCombo.getItems().addAll("DAILY", "WEEKLY", "BIWEEKLY", "MONTHLY", "QUARTERLY", "YEARLY");
        frequencyTypeCombo.setValue("MONTHLY");
        inputGrid.add(frequencyTypeCombo, 1, 1);

        inputGrid.add(new Label(messages.getString("frequencyInterval", "Frequency Interval:")), 0, 2);
        frequencyIntervalField = new TextField("1");
        inputGrid.add(frequencyIntervalField, 1, 2);

        inputGrid.add(new Label(messages.getString("nextDate", "Next Date:")), 0, 3);
        nextDateSpinner = new Spinner<>(new SpinnerValueFactory.DateSpinnerValueFactory());
        nextDateSpinner.getValueFactory().setValue(new Date());
        inputGrid.add(nextDateSpinner, 1, 3);

        inputGrid.add(new Label(messages.getString("endDate", "End Date:")), 0, 4);
        endDateSpinner = new Spinner<>(new SpinnerValueFactory.DateSpinnerValueFactory());
        endDateSpinner.getValueFactory().setValue(null);
        inputGrid.add(endDateSpinner, 1, 4);

        Button addButton = new Button(messages.getString("addRecurring", "Add Recurring Invoice"));
        addButton.setOnAction(e -> addRecurringInvoice());

        getChildren().addAll(recurringTable, inputGrid, addButton);
    }

    private void loadRecurringInvoices() {
        CompletableFuture.runAsync(() -> {
            try {
                List<RecurringInvoice> invoices = dbService.getRecurringInvoices(1, 100);
                javafx.application.Platform.runLater(() -> {
                    recurringTable.getItems().clear();
                    recurringTable.getItems().addAll(invoices);
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, "Failed to load recurring invoices", null);
            }
        }, FinancialManagementForm.executor);
    }

    private void addRecurringInvoice() {
        CompletableFuture.runAsync(() -> {
            try {
                String invoiceId = invoiceIdField.getText();
                String frequencyType = frequencyTypeCombo.getValue();
                int frequencyInterval = Integer.parseInt(frequencyIntervalField.getText());
                String nextDate = new SimpleDateFormat("yyyy-MM-dd").format(nextDateSpinner.getValue());
                String endDate = endDateSpinner.getValue() != null ?
                    new SimpleDateFormat("yyyy-MM-dd").format(endDateSpinner.getValue()) : null;

                dbService.saveRecurringInvoice(invoiceId, frequencyType, frequencyInterval, nextDate, endDate, false);
                auditService.logAction("user", "recurring_invoices", invoiceId, "Added recurring invoice", null, null);
                javafx.application.Platform.runLater(() -> {
                    loadRecurringInvoices();
                    invoiceIdField.setText("");
                    frequencyIntervalField.setText("1");
                    nextDateSpinner.getValueFactory().setValue(new Date());
                    endDateSpinner.getValueFactory().setValue(null);
                });
            } catch (Exception e) {
                ErrorHandler.handleException(e, "Failed to add recurring invoice", null);
            }
        }, FinancialManagementForm.executor);
    }
}


//=======================================   InventoryPane.java  =============================


package com.example.financial;

import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.*;
import java.util.concurrent.CompletableFuture;

public class InventoryPane extends VBox {
    private final ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private TableView<InventoryItem> inventoryTable;
    private TextField productIdField, warehouseIdField, quantityField;

    public InventoryPane(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
        loadInventory();
    }

    private void initializeUI() {
        setSpacing(10);
        setPadding(new javafx.geometry.Insets(10));

        inventoryTable = new TableView<>();
        TableColumn<InventoryItem, Integer> productIdCol = new TableColumn<>("Product ID");
        productIdCol.setCellValueFactory(new PropertyValueFactory<>("productId"));
        TableColumn<InventoryItem, Integer> warehouseIdCol = new TableColumn<>("Warehouse ID");
        warehouseIdCol.setCellValueFactory(new PropertyValueFactory<>("warehouseId"));
        TableColumn<InventoryItem, Integer> quantityCol = new TableColumn<>("Quantity");
        quantityCol.setCellValueFactory(new PropertyValueFactory<>("quantity"));
        inventoryTable.getColumns().addAll(productIdCol, warehouseIdCol, quantityCol);
        inventoryTable.setPrefHeight(300);

        GridPane inputGrid = new GridPane();
        inputGrid.setHgap(10);
        inputGrid.setVgap(10);

        inputGrid.add(new Label(messages.getString("productId", "Product ID:")), 0, 0);
        productIdField = new TextField();
        inputGrid.add(productIdField, 1, 0);

        inputGrid.add(new Label(messages.getString("warehouseId", "Warehouse ID:")), 0, 1);
        warehouseIdField = new TextField();
        inputGrid.add(warehouseIdField, 1, 1);

        inputGrid.add(new Label(messages.getString("quantity", "Quantity:")), 0, 2);
        quantityField = new TextField();
        inputGrid.add(quantityField, 1, 2);

        Button addButton = new Button(messages.getString("addInventory", "Add Inventory"));
        addButton.setOnAction(e -> addInventoryItem());

        getChildren().addAll(inventoryTable, inputGrid, addButton);
    }

    private void loadInventory() {
        CompletableFuture.runAsync(() -> {
            try {
                List<InventoryItem> items = dbService.getInventoryItems(1, 100);
                javafx.application.Platform.runLater(() -> {
                    inventoryTable.getItems().clear();
                    inventoryTable.getItems().addAll(items);
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, "Failed to load inventory", null);
            }
        }, FinancialManagementForm.executor);
    }

    private void addInventoryItem() {
        CompletableFuture.runAsync(() -> {
            try {
                int productId = Integer.parseInt(productIdField.getText());
                int warehouseId = Integer.parseInt(warehouseIdField.getText());
                int quantity = Integer.parseInt(quantityField.getText());
                dbService.addInventoryItem(productId, warehouseId, quantity);
                auditService.logAction("user", "inventory", null, "Added inventory item: Product ID " + productId, null, null);
                javafx.application.Platform.runLater(() -> {
                    loadInventory();
                    productIdField.setText("");
                    warehouseIdField.setText("");
                    quantityField.setText("");
                });
            } catch (Exception e) {
                ErrorHandler.handleException(e, "Failed to add inventory item", null);
            }
        }, FinancialManagementForm.executor);
    }
}



//==========================================   AttachmentPane.java  ====================================


package com.example.financial;

import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.*;
import java.io.File;
import java.util.List;
import java.util.concurrent.CompletableFuture;

public class AttachmentPane extends VBox {
    private final ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private TableView<Attachment> attachmentsTable;
    private TextField transactionTypeField, transactionIdField;

    public AttachmentPane(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
        loadAttachments("invoices", "");
    }

    private void initializeUI() {
        setSpacing(10);
        setPadding(new javafx.geometry.Insets(10));

        attachmentsTable = new TableView<>();
        TableColumn<Attachment, Integer> idCol = new TableColumn<>("ID");
        idCol.setCellValueFactory(new PropertyValueFactory<>("id"));
        TableColumn<Attachment, String> fileNameCol = new TableColumn<>("File Name");
        fileNameCol.setCellValueFactory(new PropertyValueFactory<>("fileName"));
        TableColumn<Attachment, Long> fileSizeCol = new TableColumn<>("Size (bytes)");
        fileSizeCol.setCellValueFactory(new PropertyValueFactory<>("fileSize"));
        TableColumn<Attachment, String> uploadDateCol = new TableColumn<>("Upload Date");
        uploadDateCol.setCellValueFactory(new PropertyValueFactory<>("uploadDate"));
        attachmentsTable.getColumns().addAll(idCol, fileNameCol, fileSizeCol, uploadDateCol);
        attachmentsTable.setPrefHeight(300);

        GridPane inputGrid = new GridPane();
        inputGrid.setHgap(10);
        inputGrid.setVgap(10);

        inputGrid.add(new Label(messages.getString("transactionType", "Transaction Type:")), 0, 0);
        transactionTypeField = new TextField("invoices");
        inputGrid.add(transactionTypeField, 1, 0);

        inputGrid.add(new Label(messages.getString("transactionId", "Transaction ID:")), 0, 1);
        transactionIdField = new TextField();
        inputGrid.add(transactionIdField, 1, 1);

        HBox buttonBox = new HBox(10);
        Button uploadButton = new Button(messages.getString("upload", "Upload"));
        uploadButton.setOnAction(e -> uploadAttachment());
        Button downloadButton = new Button(messages.getString("download", "Download"));
        downloadButton.setOnAction(e -> downloadAttachment());
        Button loadButton = new Button(messages.getString("loadAttachments", "Load Attachments"));
        loadButton.setOnAction(e -> loadAttachments(transactionTypeField.getText(), transactionIdField.getText()));
        buttonBox.getChildren().addAll(uploadButton, downloadButton, loadButton);

        getChildren().addAll(attachmentsTable, inputGrid, buttonBox);
    }

    private void loadAttachments(String transactionType, String transactionId) {
        CompletableFuture.runAsync(() -> {
            try {
                List<Attachment> attachments = dbService.getAttachments(transactionType, transactionId, 1, 100);
                javafx.application.Platform.runLater(() -> {
                    attachmentsTable.getItems().clear();
                    attachmentsTable.getItems().addAll(attachments);
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, "Failed to load attachments", null);
            }
        }, FinancialManagementForm.executor);
    }

    private void uploadAttachment() {
        CompletableFuture.runAsync(() -> {
            try {
                String transactionType = transactionTypeField.getText();
                String transactionId = transactionIdField.getText();
                if (transactionType.isEmpty() || transactionId.isEmpty()) {
                    javafx.application.Platform.runLater(() -> new Alert(Alert.AlertType.ERROR, "Please specify transaction type and ID").showAndWait());
                    return;
                }
                FileChooser fileChooser = new FileChooser();
                File file = fileChooser.showOpenDialog(getScene().getWindow());
                if (file != null) {
                    dbService.addAttachment(transactionType, transactionId, file);
                    auditService.logAction("user", "attachments", null, "Uploaded attachment: " + file.getName(), null, null);
                    javafx.application.Platform.runLater(() -> {
                        loadAttachments(transactionType, transactionId);
                        new Alert(Alert.AlertType.INFORMATION, "Attachment uploaded: " + file.getName()).showAndWait();
                    });
                }
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, "Failed to upload attachment", null);
            }
        }, FinancialManagementForm.executor);
    }

    private void downloadAttachment() {
        CompletableFuture.runAsync(() -> {
            try {
                Attachment selected = attachmentsTable.getSelectionModel().getSelectedItem();
                if (selected != null) {
                    int attachmentId = selected.getId();
                    String fileName = selected.getFileName();
                    byte[] content = dbService.getAttachmentContent(attachmentId);
                    FileChooser fileChooser = new FileChooser();
                    fileChooser.setInitialFileName(fileName);
                    File file = fileChooser.showSaveDialog(getScene().getWindow());
                    if (file != null) {
                        java.nio.file.Files.write(file.toPath(), content);
                        auditService.logAction("user", "attachments", String.valueOf(attachmentId), "Downloaded attachment: " + fileName, null, null);
                        javafx.application.Platform.runLater(() -> new Alert(Alert.AlertType.INFORMATION, "Attachment downloaded: " + fileName).showAndWait());
                    }
                } else {
                    javafx.application.Platform.runLater(() -> new Alert(Alert.AlertType.ERROR, "Please select an attachment to download").showAndWait());
                }
            } catch (Exception e) {
                ErrorHandler.handleException(e, "Failed to download attachment", null);
            }
        }, FinancialManagementForm.executor);
    }
}



//==================================    ContactsPane.java =============================================


package com.example.financial;

import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.*;
import java.util.concurrent.CompletableFuture;

public class ContactsPane extends VBox {
    private final ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private TableView<Contact> customersTable, suppliersTable;
    private TextField customerNameField, customerContactField, customerEmailField, customerAddressField,
                      supplierNameField, supplierContactField, supplierEmailField, supplierAddressField;

    public ContactsPane(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
        loadContacts();
    }

    private void initializeUI() {
        setSpacing(10);
        setPadding(new javafx.geometry.Insets(10));

        customersTable = new TableView<>();
        TableColumn<Contact, Integer> customerIdCol = new TableColumn<>("ID");
        customerIdCol.setCellValueFactory(new PropertyValueFactory<>("id"));
        TableColumn<Contact, String> customerNameCol = new TableColumn<>("Name");
        customerNameCol.setCellValueFactory(new PropertyValueFactory<>("name"));
        TableColumn<Contact, String> customerContactCol = new TableColumn<>("Contact");
        customerContactCol.setCellValueFactory(new PropertyValueFactory<>("contact"));
        TableColumn<Contact, String> customerEmailCol = new TableColumn<>("Email");
        customerEmailCol.setCellValueFactory(new PropertyValueFactory<>("email"));
        TableColumn<Contact, String> customerAddressCol = new TableColumn<>("Address");
        customerAddressCol.setCellValueFactory(new PropertyValueFactory<>("address"));
        customersTable.getColumns().addAll(customerIdCol, customerNameCol, customerContactCol, customerEmailCol, customerAddressCol);
        customersTable.setPrefHeight(200);

        suppliersTable = new TableView<>();
        TableColumn<Contact, Integer> supplierIdCol = new TableColumn<>("ID");
        supplierIdCol.setCellValueFactory(new PropertyValueFactory<>("id"));
        TableColumn<Contact, String> supplierNameCol = new TableColumn<>("Name");
        supplierNameCol.setCellValueFactory(new PropertyValueFactory<>("name"));
        TableColumn<Contact, String> supplierContactCol = new TableColumn<>("Contact");
        supplierContactCol.setCellValueFactory(new PropertyValueFactory<>("contact"));
        TableColumn<Contact, String> supplierEmailCol = new TableColumn<>("Email");
        supplierEmailCol.setCellValueFactory(new PropertyValueFactory<>("email"));
        TableColumn<Contact, String> supplierAddressCol = new TableColumn<>("Address");
        supplierAddressCol.setCellValueFactory(new PropertyValueFactory<>("address"));
        suppliersTable.getColumns().addAll(supplierIdCol, supplierNameCol, supplierContactCol, supplierEmailCol, supplierAddressCol);
        suppliersTable.setPrefHeight(200);

        GridPane inputGrid = new GridPane();
        inputGrid.setHgap(10);
        inputGrid.setVgap(10);

        inputGrid.add(new Label(messages.getString("customerName", "Customer Name:")), 0, 0);
        customerNameField = new TextField();
        inputGrid.add(customerNameField, 1, 0);
        inputGrid.add(new Label(messages.getString("customerContact", "Customer Contact:")), 0, 1);
        customerContactField = new TextField();
        inputGrid.add(customerContactField, 1, 1);
        inputGrid.add(new Label(messages.getString("customerEmail", "Customer Email:")), 0, 2);
        customerEmailField = new TextField();
        inputGrid.add(customerEmailField, 1, 2);
        inputGrid.add(new Label(messages.getString("customerAddress", "Customer Address:")), 0, 3);
        customerAddressField = new TextField();
        inputGrid.add(customerAddressField, 1, 3);

        inputGrid.add(new Label(messages.getString("supplierName", "Supplier Name:")), 0, 4);
        supplierNameField = new TextField();
        inputGrid.add(supplierNameField, 1, 4);
        inputGrid.add(new Label(messages.getString("supplierContact", "Supplier Contact:")), 0, 5);
        supplierContactField = new TextField();
        inputGrid.add(supplierContactField, 1, 5);
        inputGrid.add(new Label(messages.getString("supplierEmail", "Supplier Email:")), 0, 6);
        supplierEmailField = new TextField();
        inputGrid.add(supplierEmailField, 1, 6);
        inputGrid.add(new Label(messages.getString("supplierAddress", "Supplier Address:")), 0, 7);
        supplierAddressField = new TextField();
        inputGrid.add(supplierAddressField, 1, 7);

        HBox buttonBox = new HBox(10);
        Button addCustomerButton = new Button(messages.getString("addCustomer", "Add Customer"));
        addCustomerButton.setOnAction(e -> addCustomer());
        Button addSupplierButton = new Button(messages.getString("addSupplier", "Add Supplier"));
        addSupplierButton.setOnAction(e -> addSupplier());
        buttonBox.getChildren().addAll(addCustomerButton, addSupplierButton);

        getChildren().addAll(customersTable, suppliersTable, inputGrid, buttonBox);
    }

    private void loadContacts() {
        CompletableFuture.runAsync(() -> {
            try {
                List<Contact> customers = dbService.getCustomers(1, 100);
                List<Contact> suppliers = dbService.getSuppliers(1, 100);
                javafx.application.Platform.runLater(() -> {
                    customersTable.getItems().clear();
                    customersTable.getItems().addAll(customers);
                    suppliersTable.getItems().clear();
                    suppliersTable.getItems().addAll(suppliers);
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, "Failed to load contacts", null);
            }
        }, FinancialManagementForm.executor);
    }

    private void addCustomer() {
        CompletableFuture.runAsync(() -> {
            try {
                String name = customerNameField.getText();
                String contact = customerContactField.getText();
                String email = customerEmailField.getText();
                String address = customerAddressField.getText();
                dbService.addCustomer(name, contact, email, address);
                auditService.logAction("user", "customers", null, "Added customer: " + name, null, null);
                javafx.application.Platform.runLater(() -> {
                    loadContacts();
                    clearCustomerFields();
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, "Failed to add customer", null);
            }
        }, FinancialManagementForm.executor);
    }

    private void addSupplier() {
        CompletableFuture.runAsync(() -> {
            try {
                String name = supplierNameField.getText();
                String contact = supplierContactField.getText();
                String email = supplierEmailField.getText();
                String address = supplierAddressField.getText();
                dbService.addSupplier(name, contact, email, address);
                auditService.logAction("user", "suppliers", null, "Added supplier: " + name, null, null);
                javafx.application.Platform.runLater(() -> {
                    loadContacts();
                    clearSupplierFields();
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, "Failed to add supplier", null);
            }
        }, FinancialManagementForm.executor);
    }

    private void clearCustomerFields() {
        customerNameField.setText("");
        customerContactField.setText("");
        customerEmailField.setText("");
        customerAddressField.setText("");
    }

    private void clearSupplierFields() {
        supplierNameField.setText("");
        supplierContactField.setText("");
        supplierEmailField.setText("");
        supplierAddressField.setText("");
    }
}




//===================================  ExpensesPane.java =================================


package com.example.financial;

import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.*;
import java.text.SimpleDateFormat;
import java.util.List;
import java.util.concurrent.CompletableFuture;

public class ExpensesPane extends VBox {
    private final ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private TableView<Expense> expensesTable;
    private TextField descriptionField, amountField, currencyField, categoryField, dateField,
                      budgetAmountField, budgetStartDateField, budgetEndDateField;

    public ExpensesPane(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
        loadExpenses();
    }

    private void initializeUI() {
        setSpacing(10);
        setPadding(new javafx.geometry.Insets(10));

        expensesTable = new TableView<>();
        TableColumn<Expense, String> descriptionCol = new TableColumn<>("Description");
        descriptionCol.setCellValueFactory(new PropertyValueFactory<>("description"));
        TableColumn<Expense, Double> amountCol = new TableColumn<>("Amount");
        amountCol.setCellValueFactory(new PropertyValueFactory<>("amount"));
        TableColumn<Expense, String> currencyCol = new TableColumn<>("Currency");
        currencyCol.setCellValueFactory(new PropertyValueFactory<>("currency"));
        TableColumn<Expense, String> categoryCol = new TableColumn<>("Category");
        categoryCol.setCellValueFactory(new PropertyValueFactory<>("category"));
        TableColumn<Expense, String> dateCol = new TableColumn<>("Date");
        dateCol.setCellValueFactory(new PropertyValueFactory<>("date"));
        expensesTable.getColumns().addAll(descriptionCol, amountCol, currencyCol, categoryCol, dateCol);
        expensesTable.setPrefHeight(300);

        GridPane inputGrid = new GridPane();
        inputGrid.setHgap(10);
        inputGrid.setVgap(10);

        inputGrid.add(new Label(messages.getString("description", "Description:")), 0, 0);
        descriptionField = new TextField();
        inputGrid.add(descriptionField, 1, 0);

        inputGrid.add(new Label(messages.getString("amount", "Amount:")), 0, 1);
        amountField = new TextField();
        inputGrid.add(amountField, 1, 1);

        inputGrid.add(new Label(messages.getString("currency", "Currency:")), 0, 2);
        currencyField = new TextField("USD");
        inputGrid.add(currencyField, 1, 2);

        inputGrid.add(new Label(messages.getString("category", "Category:")), 0, 3);
        categoryField = new TextField();
        inputGrid.add(categoryField, 1, 3);

        inputGrid.add(new Label(messages.getString("date", "Date:")), 0, 4);
        dateField = new TextField(new SimpleDateFormat("yyyy-MM-dd").format(new java.util.Date()));
        inputGrid.add(dateField, 1, 4);

        inputGrid.add(new Label(messages.getString("budgetAmount", "Budget Amount:")), 0, 5);
        budgetAmountField = new TextField();
        inputGrid.add(budgetAmountField, 1, 5);

        inputGrid.add(new Label(messages.getString("budgetStartDate", "Budget Start Date:")), 0, 6);
        budgetStartDateField = new TextField(new SimpleDateFormat("yyyy-MM-dd").format(new java.util.Date()));
        inputGrid.add(budgetStartDateField, 1, 6);

        inputGrid.add(new Label(messages.getString("budgetEndDate", "Budget End Date:")), 0, 7);
        budgetEndDateField = new TextField("");
        inputGrid.add(budgetEndDateField, 1, 7);

        HBox buttonBox = new HBox(10);
        Button addButton = new Button(messages.getString("addExpense", "Add Expense"));
        addButton.setOnAction(e -> addExpense());
        Button setBudgetButton = new Button(messages.getString("setBudget", "Set Budget"));
        setBudgetButton.setOnAction(e -> setBudget());
        buttonBox.getChildren().addAll(addButton, setBudgetButton);

        getChildren().addAll(expensesTable, inputGrid, buttonBox);
    }

    private void loadExpenses() {
        CompletableFuture.runAsync(() -> {
            try {
                List<Expense> expenses = dbService.getExpenses(1, 100);
                javafx.application.Platform.runLater(() -> {
                    expensesTable.getItems().clear();
                    expensesTable.getItems().addAll(expenses);
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, "Failed to load expenses", null);
            }
        }, FinancialManagementApp.executor);
    }

    private void addExpense() {
        CompletableFuture.runAsync(() -> {
            try {
                String description = descriptionField.getText();
                double amount = Double.parseDouble(amountField.getText());
                String currency = currencyField.getText();
                String category = categoryField.getText();
                String date = dateField.getText();
                dbService.addExpense(description, amount, currency, category, date);
                auditService.logAction("user", "expenses", null, "Added expense: " + description, null, null);
                javafx.application.Platform.runLater(() -> {
                    loadExpenses();
                    descriptionField.setText("");
                    amountField.setText("");
                    currencyField.setText("USD");
                    categoryField.setText("");
                    dateField.setText(new SimpleDateFormat("yyyy-MM-dd").format(new java.util.Date()));
                });
            } catch (Exception e) {
                ErrorHandler.handleException(e, "Failed to add expense", null);
            }
        }, FinancialManagementApp.executor);
    }

    private void setBudget() {
        CompletableFuture.runAsync(() -> {
            try {
                String category = categoryField.getText();
                double amount = Double.parseDouble(budgetAmountField.getText());
                String startDate = budgetStartDateField.getText();
                String endDate = budgetEndDateField.getText().isEmpty() ? LocalDate.now().plusMonths(1).toString() : budgetEndDateField.getText();
                dbService.setBudget(category, amount, startDate, endDate);
                auditService.logAction("user", "budgets", null, "Set budget for " + category, null, null);
                javafx.application.Platform.runLater(() -> 
                    new Alert(Alert.AlertType.INFORMATION, "Budget set for " + category).showAndWait());
            } catch (Exception e) {
                ErrorHandler.handleException(e, "Failed to set budget", null);
            }
        }, FinancialManagementApp.executor);
    }
}



//=============================================================src/main/java/com/example/financial/ReportPane.java ================================================


package com.example.financial;

import javafx.scene.control.*;
import javafx.scene.layout.*;
import java.text.SimpleDateFormat;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

public class ReportPane extends VBox {
    private final ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private ComboBox<String> reportTypeCombo;
    private DatePicker startDatePicker, endDatePicker;
    private TextArea reportArea;

    public ReportPane(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
    }

    private void initializeUI() {
        setSpacing(10);
        setPadding(new javafx.geometry.Insets(10));

        HBox controls = new HBox(10);
        controls.setPadding(new javafx.geometry.Insets(10));

        reportTypeCombo = new ComboBox<>();
        reportTypeCombo.getItems().addAll("Financial Summary", "Cash Flow", "Balance Sheet", "Profit & Loss", "Aging Report",
            "Sales by Customer", "Sales by Product", "Tax Report", "Cash Flow Projection", "Budget vs Actual", "Cash Flow Forecast");
        reportTypeCombo.setValue("Financial Summary");
        controls.getChildren().add(new Label(messages.getString("reportType", "Report Type:")));
        controls.getChildren().add(reportTypeCombo);

        startDatePicker = new DatePicker();
        startDatePicker.setPromptText("YYYY-MM-DD");
        controls.getChildren().add(new Label(messages.getString("startDate", "Start Date:")));
        controls.getChildren().add(startDatePicker);

        endDatePicker = new DatePicker();
        endDatePicker.setPromptText("YYYY-MM-DD");
        controls.getChildren().add(new Label(messages.getString("endDate", "End Date:")));
        controls.getChildren().add(endDatePicker);

        Button generateButton = new Button(messages.getString("generate", "Generate"));
        generateButton.setOnAction(e -> generateReport());
        controls.getChildren().add(generateButton);

        reportArea = new TextArea();
        reportArea.setEditable(false);
        reportArea.setPrefHeight(400);
        reportArea.setWrapText(true);

        getChildren().addAll(controls, reportArea);
    }

    private void generateReport() {
        CompletableFuture.runAsync(() -> {
            try {
                String reportType = reportTypeCombo.getValue();
                if (startDatePicker.getValue() == null || endDatePicker.getValue() == null) {
                    javafx.application.Platform.runLater(() -> 
                        new Alert(Alert.AlertType.ERROR, "Please select start and end dates").showAndWait());
                    return;
                }
                String startDate = startDatePicker.getValue().toString();
                String endDate = endDatePicker.getValue().toString();
                StringBuilder report = new StringBuilder(reportType + " Report (" + startDate + " to " + endDate + ")\n");
                report.append("------------------------------------------------\n");

                switch (reportType) {
                    case "Financial Summary":
                        Map<String, Double> financialSummary = dbService.generateCompanyFinancialSummary(startDate, endDate);
                        financialSummary.forEach((k, v) -> report.append(k).append(": ").append(String.format("%.2f", v)).append(" USD\n"));
                        break;
                    case "Cash Flow":
                        Map<String, Double> cashFlow = dbService.generateCashFlowStatement(startDate, endDate);
                        cashFlow.forEach((k, v) -> report.append(k).append(": ").append(String.format("%.2f", v)).append(" USD\n"));
                        break;
                    case "Balance Sheet":
                        Map<String, Double> balanceSheet = dbService.generateBalanceSheet(startDate, endDate);
                        balanceSheet.forEach((k, v) -> report.append(k).append(": ").append(String.format("%.2f", v)).append(" USD\n"));
                        break;
                    case "Profit & Loss":
                        Map<String, Double> profitLoss = dbService.generateProfitLossStatement(startDate, endDate);
                        profitLoss.forEach((k, v) -> report.append(k).append(": ").append(String.format("%.2f", v)).append(" USD\n"));
                        break;
                    case "Aging Report":
                        List<Object[]> aging = dbService.getAgingAnalysis();
                        report.append("Invoice ID | Customer | Amount | Days Overdue\n");
                        for (Object[] row : aging) {
                            report.append(row[0]).append(" | ").append(row[1]).append(" | ")
                                  .append(String.format("%.2f", (Double) row[2])).append(" | ").append(row[3]).append("\n");
                        }
                        break;
                    case "Sales by Customer":
                        Map<String, Double> salesByCustomer = dbService.getSalesByCustomer(startDate, endDate);
                        salesByCustomer.forEach((k, v) -> report.append(k).append(": ").append(String.format("%.2f", v)).append(" USD\n"));
                        break;
                    case "Sales by Product":
                        Map<String, Double> salesByProduct = dbService.getSalesByProduct(startDate, endDate);
                        salesByProduct.forEach((k, v) -> report.append(k).append(": ").append(String.format("%.2f", v)).append(" USD\n"));
                        break;
                    case "Tax Report":
                        Map<String, Double> taxReport = dbService.getTaxReport(startDate, endDate);
                        taxReport.forEach((k, v) -> report.append(k).append(": ").append(String.format("%.2f", v)).append(" USD\n"));
                        break;
                    case "Cash Flow Projection":
                        Map<String, Double> projection = dbService.getCashFlowProjection(startDate, endDate);
                        projection.forEach((k, v) -> report.append(k).append(": ").append(String.format("%.2f", v)).append(" USD\n"));
                        break;
                    case "Budget vs Actual":
                        Map<String, Double> budgetVsActual = dbService.getBudgetVsActual(startDate, endDate);
                        budgetVsActual.forEach((k, v) -> report.append(k).append(": ").append(String.format("%.2f", v)).append(" USD\n"));
                        break;
                    case "Cash Flow Forecast":
                        Map<String, Double> forecast = dbService.getCashFlowForecast(startDate, endDate, 7); // 7-day forecast
                        forecast.forEach((k, v) -> report.append(k).append(": ").append(String.format("%.2f", v)).append(" USD\n"));
                        break;
                    default:
                        report.append("Unknown report type\n");
                }

                javafx.application.Platform.runLater(() -> reportArea.setText(report.toString()));
                auditService.logAction("user", "reports", null, "Generated " + reportType + " report", null, null);
            } catch (Exception e) {
                ErrorHandler.handleException(e, "Failed to generate report", null);
            }
        }, FinancialManagementApp.executor);
    }
}
//=============================================== NEW ============= 15. AdjustmentsPane.java ===================================================

package com.example.financial;

import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.*;
import java.text.SimpleDateFormat;
import java.util.concurrent.CompletableFuture;

public class AdjustmentsPane extends VBox {
    private final ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private TableView<Adjustment> adjustmentsTable;
    private TextField typeField, descriptionField, amountField, accountFromField, accountToField, dateField, currencyField, exchangeRateField;

    public AdjustmentsPane(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
        loadAdjustments();
    }

    private void initializeUI() {
        setSpacing(10);
        setPadding(new javafx.geometry.Insets(10));

        adjustmentsTable = new TableView<>();
        TableColumn<Adjustment, Integer> idCol = new TableColumn<>("ID");
        idCol.setCellValueFactory(new PropertyValueFactory<>("id"));
        TableColumn<Adjustment, String> typeCol = new TableColumn<>("Type");
        typeCol.setCellValueFactory(new PropertyValueFactory<>("type"));
        TableColumn<Adjustment, String> descriptionCol = new TableColumn<>("Description");
        descriptionCol.setCellValueFactory(new PropertyValueFactory<>("description"));
        TableColumn<Adjustment, Double> amountCol = new TableColumn<>("Amount");
        amountCol.setCellValueFactory(new PropertyValueFactory<>("amount"));
        TableColumn<Adjustment, Integer> accountFromCol = new TableColumn<>("From Account");
        accountFromCol.setCellValueFactory(new PropertyValueFactory<>("accountFrom"));
        TableColumn<Adjustment, Integer> accountToCol = new TableColumn<>("To Account");
        accountToCol.setCellValueFactory(new PropertyValueFactory<>("accountTo"));
        TableColumn<Adjustment, String> dateCol = new TableColumn<>("Date");
        dateCol.setCellValueFactory(new PropertyValueFactory<>("date"));
        TableColumn<Adjustment, String> currencyCol = new TableColumn<>("Currency");
        currencyCol.setCellValueFactory(new PropertyValueFactory<>("currency"));
        TableColumn<Adjustment, Double> exchangeRateCol = new TableColumn<>("Exchange Rate");
        exchangeRateCol.setCellValueFactory(new PropertyValueFactory<>("exchangeRate"));
        adjustmentsTable.getColumns().addAll(idCol, typeCol, descriptionCol, amountCol, accountFromCol, accountToCol, dateCol, currencyCol, exchangeRateCol);
        adjustmentsTable.setPrefHeight(300);

        GridPane inputGrid = new GridPane();
        inputGrid.setHgap(10);
        inputGrid.setVgap(10);

        inputGrid.add(new Label(messages.getString("type", "Type:")), 0, 0);
        typeField = new TextField();
        inputGrid.add(typeField, 1, 0);
        inputGrid.add(new Label(messages.getString("description", "Description:")), 0, 1);
        descriptionField = new TextField();
        inputGrid.add(descriptionField, 1, 1);
        inputGrid.add(new Label(messages.getString("amount", "Amount:")), 0, 2);
        amountField = new TextField();
        inputGrid.add(amountField, 1, 2);
        inputGrid.add(new Label(messages.getString("accountFrom", "From Account:")), 0, 3);
        accountFromField = new TextField();
        inputGrid.add(accountFromField, 1, 3);
        inputGrid.add(new Label(messages.getString("accountTo", "To Account:")), 0, 4);
        accountToField = new TextField();
        inputGrid.add(accountToField, 1, 4);
        inputGrid.add(new Label(messages.getString("date", "Date:")), 0, 5);
        dateField = new TextField(new SimpleDateFormat("yyyy-MM-dd").format(new java.util.Date()));
        inputGrid.add(dateField, 1, 5);
        inputGrid.add(new Label(messages.getString("currency", "Currency:")), 0, 6);
        currencyField = new TextField("USD");
        inputGrid.add(currencyField, 1, 6);
        inputGrid.add(new Label(messages.getString("exchangeRate", "Exchange Rate:")), 0, 7);
        exchangeRateField = new TextField("1.0");
        inputGrid.add(exchangeRateField, 1, 7);

        Button addButton = new Button(messages.getString("addAdjustment", "Add Adjustment"));
        addButton.setOnAction(e -> addAdjustment());

        getChildren().addAll(adjustmentsTable, inputGrid, addButton);
    }

    private void loadAdjustments() {
        CompletableFuture.runAsync(() -> {
            try {
                List<Adjustment> adjustments = dbService.getAdjustments(1, 100);
                javafx.application.Platform.runLater(() -> {
                    adjustmentsTable.getItems().clear();
                    adjustmentsTable.getItems().addAll(adjustments);
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, "Failed to load adjustments", null);
            }
        }, FinancialManagementForm.executor);
    }

    private void addAdjustment() {
        CompletableFuture.runAsync(() -> {
            try {
                String type = typeField.getText().toUpperCase();
                String description = descriptionField.getText();
                double amount = Double.parseDouble(amountField.getText());
                Integer accountFrom = accountFromField.getText().isEmpty() ? null : Integer.parseInt(accountFromField.getText());
                Integer accountTo = accountToField.getText().isEmpty() ? null : Integer.parseInt(accountToField.getText());
                String date = dateField.getText();
                String currency = currencyField.getText();
                double exchangeRate = Double.parseDouble(exchangeRateField.getText());
                dbService.addAdjustment(type, description, amount, accountFrom, accountTo, date, currency, exchangeRate);
                auditService.logAction("user", "adjustments", null, "Added adjustment: " + description, null, null);
                javafx.application.Platform.runLater(() -> {
                    loadAdjustments();
                    clearFields();
                });
            } catch (Exception e) {
                ErrorHandler.handleException(e, "Failed to add adjustment", null);
            }
        }, FinancialManagementForm.executor);
    }

    private void clearFields() {
        typeField.setText("");
        descriptionField.setText("");
        amountField.setText("");
        accountFromField.setText("");
        accountToField.setText("");
        dateField.setText(new SimpleDateFormat("yyyy-MM-dd").format(new java.util.Date()));
        currencyField.setText("USD");
        exchangeRateField.setText("1.0");
    }
}



//================================== NEW ======================= 19. AuditTrailPane.java ========================================================================

package com.example.financial;

import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.*;
import java.util.concurrent.CompletableFuture;

public class AuditTrailPane extends VBox {
    private final ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private TableView<AuditEntry> auditTable;

    public AuditTrailPane(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
        loadAuditLogs();
    }

    private void initializeUI() {
        setSpacing(10);
        setPadding(new javafx.geometry.Insets(10));

        auditTable = new TableView<>();
        TableColumn<AuditEntry, String> timestampCol = new TableColumn<>("Timestamp");
        timestampCol.setCellValueFactory(new PropertyValueFactory<>("timestamp"));
        TableColumn<AuditEntry, String> userCol = new TableColumn<>("User");
        userCol.setCellValueFactory(new PropertyValueFactory<>("user"));
        TableColumn<AuditEntry, String> tableNameCol = new TableColumn<>("Table");
        tableNameCol.setCellValueFactory(new PropertyValueFactory<>("tableName"));
        TableColumn<AuditEntry, String> recordIdCol = new TableColumn<>("Record ID");
        recordIdCol.setCellValueFactory(new PropertyValueFactory<>("recordId"));
        TableColumn<AuditEntry, String> actionCol = new TableColumn<>("Action");
        actionCol.setCellValueFactory(new PropertyValueFactory<>("action"));
        TableColumn<AuditEntry, String> oldValueCol = new TableColumn<>("Old Value");
        oldValueCol.setCellValueFactory(new PropertyValueFactory<>("oldValue"));
        TableColumn<AuditEntry, String> newValueCol = new TableColumn<>("New Value");
        newValueCol.setCellValueFactory(new PropertyValueFactory<>("newValue"));
        auditTable.getColumns().addAll(timestampCol, userCol, tableNameCol, recordIdCol, actionCol, oldValueCol, newValueCol);
        auditTable.setPrefHeight(400);

        getChildren().add(auditTable);
    }

    private void loadAuditLogs() {
        CompletableFuture.runAsync(() -> {
            try {
                List<AuditEntry> logs = dbService.getAuditLogs(1, 100);
                javafx.application.Platform.runLater(() -> {
                    auditTable.getItems().clear();
                    auditTable.getItems().addAll(logs);
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, "Failed to load audit logs", null);
            }
        }, FinancialManagementForm.executor);
    }
}


//======================================================================1. DatabaseService.java=====================

package com.example.financial;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import gnu.trove.list.TIntList;
import gnu.trove.list.array.TIntArrayList;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Flux;
import reactor.core.scheduler.Schedulers;

import java.io.File;
import java.nio.file.Files;
import java.sql.*;
import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class DatabaseService {
    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseService.class);
    private static final int MAX_POOL_SIZE = 20;
    private static final int MIN_IDLE = 5;
    private static final int CACHE_SIZE = 1000;
    private static final Pattern DB_NAME_PATTERN = Pattern.compile("[a-zA-Z0-9_]+");
    public static final HikariDataSource dataSource; // Made public for ExchangeRateService
    private static final ObjectMapper objectMapper = new ObjectMapper();

    static {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(System.getenv("DB_URL") != null ? System.getenv("DB_URL") : "jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1");
        config.setUsername(System.getenv("DB_USER") != null ? System.getenv("DB_USER") : "sa");
        config.setPassword(System.getenv("DB_PASS") != null ? System.getenv("DB_PASS") : "");
        config.setMaximumPoolSize(MAX_POOL_SIZE);
        config.setMinimumIdle(MIN_IDLE);
        config.setConnectionTimeout(30000);
        config.setIdleTimeout(600000);
        config.addDataSourceProperty("cachePrepStmts", "true");
        config.addDataSourceProperty("prepStmtCacheSize", "250");
        config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
        dataSource = new HikariDataSource(config);
    }

    private final LoadingCache<Integer, String> customerCache = Caffeine.newBuilder()
        .maximumSize(CACHE_SIZE)
        .expireAfterWrite(Duration.ofMinutes(30))
        .build(this::fetchCustomerName);

    private final LoadingCache<Integer, Product> productCache = Caffeine.newBuilder()
        .maximumSize(CACHE_SIZE)
        .expireAfterWrite(Duration.ofMinutes(30))
        .build(this::fetchProduct);

    private final LoadingCache<Integer, String> warehouseCache = Caffeine.newBuilder()
        .maximumSize(CACHE_SIZE)
        .expireAfterWrite(Duration.ofMinutes(30))
        .build(this::fetchWarehouseName);

    private final LoadingCache<Integer, String> supplierCache = Caffeine.newBuilder()
        .maximumSize(CACHE_SIZE)
        .expireAfterWrite(Duration.ofMinutes(30))
        .build(this::fetchSupplierName);

    public DatabaseService() {
        initializeDatabase();
    }

    public void createNewDatabase(String dbName) throws DatabaseException {
        if (!DB_NAME_PATTERN.matcher(dbName).matches()) {
            throw new DatabaseException("Invalid database name: " + dbName, null);
        }
        String baseUrl = dataSource.getJdbcUrl().substring(0, dataSource.getJdbcUrl().lastIndexOf("/") + 1);
        try (Connection conn = DriverManager.getConnection(baseUrl, dataSource.getUsername(), dataSource.getPassword());
             PreparedStatement stmt = conn.prepareStatement("CREATE DATABASE IF NOT EXISTS " + dbName)) {
            stmt.executeUpdate();
            LOGGER.info("Created new database: {}", dbName);
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to create database: " + dbName, e);
        }
    }

    public void initializeDatabase() throws DatabaseException {
        try (Connection connection = dataSource.getConnection();
             Statement statement = connection.createStatement()) {
            statement.execute("CREATE TABLE IF NOT EXISTS Customers (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, contact VARCHAR(50), email VARCHAR(100), address VARCHAR(255), INDEX idx_customers_name (name))");
            statement.execute("CREATE TABLE IF NOT EXISTS Suppliers (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, contact VARCHAR(50), email VARCHAR(100), address VARCHAR(255), INDEX idx_suppliers_name (name))");
            statement.execute("CREATE TABLE IF NOT EXISTS Warehouses (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, INDEX idx_warehouses_name (name))");
            statement.execute("CREATE TABLE IF NOT EXISTS Products (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, sellingPrice DOUBLE NOT NULL, costPrice DOUBLE NOT NULL, unit VARCHAR(50) NOT NULL, INDEX idx_products_name (name))");
            statement.execute("CREATE TABLE IF NOT EXISTS Invoices (id VARCHAR(50) PRIMARY KEY, customerId INT, type ENUM('SALE', 'PURCHASE', 'IMPORT', 'SALE_RETURN', 'PURCHASE_RETURN') NOT NULL, date DATE NOT NULL, totalAmount DOUBLE NOT NULL, totalTax DOUBLE NOT NULL DEFAULT 0.0, currency VARCHAR(50) NOT NULL, paymentCurrency VARCHAR(50) NOT NULL, paymentInstructions VARCHAR(255), paymentTerm VARCHAR(50), deliveryStatus ENUM('DRAFT', 'SENT', 'VIEWED', 'PAID', 'OVERDUE') NOT NULL DEFAULT 'DRAFT', notes TEXT, exchangeRate DOUBLE NOT NULL, invoiceDiscount DOUBLE NOT NULL DEFAULT 0.0, invoiceFixedDiscount DOUBLE NOT NULL DEFAULT 0.0, invoiceTaxRate DOUBLE NOT NULL DEFAULT 0.0, shippingCharge DOUBLE NOT NULL DEFAULT 0.0, logoPath VARCHAR(255), customFields TEXT, FOREIGN KEY (customerId) REFERENCES Customers(id), INDEX idx_invoices_type_date (type, date))");
            statement.execute("CREATE TABLE IF NOT EXISTS InvoiceLineItems (id INT AUTO_INCREMENT PRIMARY KEY, invoiceId VARCHAR(50) NOT NULL, productId INT NOT NULL, warehouseId INT NOT NULL, quantity INT NOT NULL, unit VARCHAR(50) NOT NULL, unitPrice DOUBLE NOT NULL, totalPrice DOUBLE NOT NULL, unitCost DOUBLE NOT NULL, totalCost DOUBLE NOT NULL, discount DOUBLE NOT NULL DEFAULT 0.0, fixedDiscount DOUBLE NOT NULL DEFAULT 0.0, taxRate DOUBLE NOT NULL DEFAULT 0.0, totalTax DOUBLE NOT NULL DEFAULT 0.0, currency VARCHAR(3) NOT NULL DEFAULT 'USD', FOREIGN KEY (invoiceId) REFERENCES Invoices(id), FOREIGN KEY (productId) REFERENCES Products(id), FOREIGN KEY (warehouseId) REFERENCES Warehouses(id), INDEX idx_lineitems_invoice_product (invoiceId, productId))");
            statement.execute("CREATE TABLE IF NOT EXISTS Inventory (productId INT NOT NULL, warehouseId INT NOT NULL, quantity INT NOT NULL, PRIMARY KEY (productId, warehouseId), FOREIGN KEY (productId) REFERENCES Products(id), FOREIGN KEY (warehouseId) REFERENCES Warehouses(id), INDEX idx_inventory_product_warehouse (productId, warehouseId))");
            statement.execute("CREATE TABLE IF NOT EXISTS InventoryTransactions (id INT AUTO_INCREMENT PRIMARY KEY, productId INT NOT NULL, warehouseId INT NOT NULL, quantity INT NOT NULL, type ENUM('IN', 'OUT') NOT NULL, date DATETIME NOT NULL, cost DOUBLE NOT NULL, FOREIGN KEY (productId) REFERENCES Products(id), FOREIGN KEY (warehouseId) REFERENCES Warehouses(id), INDEX idx_invtrans_product_date (productId, date))");
            statement.execute("CREATE TABLE IF NOT EXISTS Attachments (id INT AUTO_INCREMENT PRIMARY KEY, transactionType VARCHAR(50) NOT NULL, transactionId VARCHAR(50) NOT NULL, fileName VARCHAR(255) NOT NULL, fileSize BIGINT NOT NULL, uploadDate DATETIME NOT NULL, content BLOB NOT NULL, INDEX idx_attachments_transaction (transactionType, transactionId))");
            statement.execute("CREATE TABLE IF NOT EXISTS Payments (id INT AUTO_INCREMENT PRIMARY KEY, customerId INT NOT NULL, invoiceId VARCHAR(50), amount DOUBLE NOT NULL, paymentDate DATETIME NOT NULL, currency VARCHAR(3) NOT NULL DEFAULT 'USD', exchangeRate DOUBLE NOT NULL, FOREIGN KEY (customerId) REFERENCES Customers(id), FOREIGN KEY (invoiceId) REFERENCES Invoices(id), INDEX idx_payments_customer_date (customerId, paymentDate))");
            statement.execute("CREATE TABLE IF NOT EXISTS CashTransactions (id INT AUTO_INCREMENT PRIMARY KEY, description VARCHAR(255) NOT NULL, amount DOUBLE NOT NULL, type ENUM('IN', 'OUT') NOT NULL, category VARCHAR(50) NOT NULL DEFAULT 'Other', date DATETIME NOT NULL, budgetId INT, INDEX idx_cash_date_category (date, category))");
            statement.execute("CREATE TABLE IF NOT EXISTS CustomerDebits (id INT AUTO_INCREMENT PRIMARY KEY, customerId INT NOT NULL, amount DOUBLE NOT NULL, description VARCHAR(255), date DATETIME NOT NULL, FOREIGN KEY (customerId) REFERENCES Customers(id), INDEX idx_debits_customer_date (customerId, date))");
            statement.execute("CREATE TABLE IF NOT EXISTS CustomerCredits (id INT AUTO_INCREMENT PRIMARY KEY, customerId INT NOT NULL, amount DOUBLE NOT NULL, description VARCHAR(255), date DATETIME NOT NULL, FOREIGN KEY (customerId) REFERENCES Customers(id), INDEX idx_credits_customer_date (customerId, date))");
            statement.execute("CREATE TABLE IF NOT EXISTS AuditLog (id INT AUTO_INCREMENT PRIMARY KEY, user VARCHAR(50) NOT NULL, tableName VARCHAR(50), recordId VARCHAR(50), action VARCHAR(255) NOT NULL, oldValue TEXT, newValue TEXT, timestamp DATETIME NOT NULL, INDEX idx_audit_timestamp (timestamp))");
            statement.execute("CREATE TABLE IF NOT EXISTS InvoiceHistory (id INT AUTO_INCREMENT PRIMARY KEY, invoiceId VARCHAR(50) NOT NULL, changeDescription TEXT NOT NULL, changedBy VARCHAR(50) NOT NULL, changeDate DATETIME NOT NULL, FOREIGN KEY (invoiceId) REFERENCES Invoices(id), INDEX idx_history_invoice (invoiceId))");
            statement.execute("CREATE TABLE IF NOT EXISTS Adjustments (id INT AUTO_INCREMENT PRIMARY KEY, type ENUM('BALANCE_TRANSFER', 'INVENTORY_VALUATION', 'DEFERRED_EXPENSE', 'ACCRUED_REVENUE', 'TAX_DUE', 'OTHER_PAYMENT') NOT NULL, description VARCHAR(255) NOT NULL, amount DOUBLE NOT NULL, accountFrom INT, accountTo INT, date DATETIME NOT NULL, currency VARCHAR(3) NOT NULL DEFAULT 'USD', exchangeRate DOUBLE NOT NULL DEFAULT 1.0, FOREIGN KEY (accountFrom) REFERENCES Customers(id), FOREIGN KEY (accountTo) REFERENCES Customers(id), INDEX idx_adjustments_type_date (type, date))");
            statement.execute("CREATE TABLE IF NOT EXISTS RecurringInvoices (id INT AUTO_INCREMENT PRIMARY KEY, invoiceId VARCHAR(50) NOT NULL, frequencyType ENUM('DAILY', 'WEEKLY', 'BIWEEKLY', 'MONTHLY', 'QUARTERLY', 'YEARLY') NOT NULL, frequencyInterval INT NOT NULL, nextDate DATE NOT NULL, endDate DATE, lastGenerated DATE, FOREIGN KEY (invoiceId) REFERENCES Invoices(id), INDEX idx_recurring_nextdate (nextDate))");
            statement.execute("CREATE TABLE IF NOT EXISTS Budgets (id INT AUTO_INCREMENT PRIMARY KEY, category VARCHAR(50) NOT NULL, amount DOUBLE NOT NULL, period VARCHAR(20) NOT NULL DEFAULT 'Monthly', INDEX idx_budgets_category (category))");
            statement.execute("CREATE TABLE IF NOT EXISTS InvoiceTemplates (name VARCHAR(255) PRIMARY KEY, invoiceType VARCHAR(50) NOT NULL, customerId INT, date VARCHAR(10), paymentTerms VARCHAR(255), templateStyle TEXT, brandingColors TEXT, brandingFont VARCHAR(50), FOREIGN KEY (customerId) REFERENCES Customers(id))");
            statement.execute("CREATE TABLE IF NOT EXISTS InvoiceTemplateItems (id INT AUTO_INCREMENT PRIMARY KEY, templateName VARCHAR(255) NOT NULL, productId INT NOT NULL, warehouseId INT NOT NULL, quantity INT NOT NULL, unit VARCHAR(50) NOT NULL, unitPrice DOUBLE NOT NULL, totalPrice DOUBLE NOT NULL, unitCost DOUBLE NOT NULL, totalCost DOUBLE NOT NULL, discount DOUBLE NOT NULL DEFAULT 0.0, fixedDiscount DOUBLE NOT NULL DEFAULT 0.0, taxRate DOUBLE NOT NULL DEFAULT 0.0, totalTax DOUBLE NOT NULL DEFAULT 0.0, currency VARCHAR(3) NOT NULL DEFAULT 'USD', FOREIGN KEY (templateName) REFERENCES InvoiceTemplates(name), FOREIGN KEY (productId) REFERENCES Products(id), FOREIGN KEY (warehouseId) REFERENCES Warehouses(id))");
            statement.execute("CREATE TABLE IF NOT EXISTS InvoiceComments (id INT AUTO_INCREMENT PRIMARY KEY, invoiceId VARCHAR(50) NOT NULL, user VARCHAR(50) NOT NULL, commentText TEXT NOT NULL, timestamp DATETIME NOT NULL, FOREIGN KEY (invoiceId) REFERENCES Invoices(id))");
            statement.execute("CREATE TABLE IF NOT EXISTS PaymentPlanRequests (id INT AUTO_INCREMENT PRIMARY KEY, invoiceId VARCHAR(50) NOT NULL, installments INT NOT NULL, requestedBy VARCHAR(50) NOT NULL, requestDate DATETIME NOT NULL, FOREIGN KEY (invoiceId) REFERENCES Invoices(id))");
            statement.execute("CREATE TABLE IF NOT EXISTS ExchangeRates (currencyFrom VARCHAR(3) NOT NULL, currencyTo VARCHAR(3) NOT NULL, rate DOUBLE NOT NULL, lastUpdated DATETIME NOT NULL, PRIMARY KEY (currencyFrom, currencyTo))");
            LOGGER.info("Database initialized successfully");
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to initialize database", e);
        }
    }

    public void loadCustomers(JComboBox<String> customerDropdown, int pageNumber, int pageSize) throws DatabaseException {
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT id, name FROM Customers ORDER BY name LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            customerDropdown.removeAllItems();
            while (rs.next()) {
                int id = rs.getInt("id");
                String name = rs.getString("name");
                customerCache.put(id, name);
                customerDropdown.addItem(id + " - " + name);
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to load customers", e);
        }
    }

    public List<Contact> getCustomers(int pageNumber, int pageSize) throws DatabaseException {
        List<Contact> customers = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT id, name, contact, email, address FROM Customers ORDER BY name LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                customers.add(new Contact(rs.getInt("id"), rs.getString("name"), rs.getString("contact"), rs.getString("email"), rs.getString("address")));
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get customers", e);
        }
        return customers;
    }

    public int getCustomerCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM Customers")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get customer count", e);
        }
    }

    public void loadSuppliers(JComboBox<String> supplierDropdown, int pageNumber, int pageSize) throws DatabaseException {
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT id, name FROM Suppliers ORDER BY name LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            supplierDropdown.removeAllItems();
            while (rs.next()) {
                int id = rs.getInt("id");
                String name = rs.getString("name");
                supplierCache.put(id, name);
                supplierDropdown.addItem(id + " - " + name);
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to load suppliers", e);
        }
    }

    public List<Contact> getSuppliers(int pageNumber, int pageSize) throws DatabaseException {
        List<Contact> suppliers = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT id, name, contact, email, address FROM Suppliers ORDER BY name LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                suppliers.add(new Contact(rs.getInt("id"), rs.getString("name"), rs.getString("contact"), rs.getString("email"), rs.getString("address")));
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get suppliers", e);
        }
        return suppliers;
    }

    public int getSupplierCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM Suppliers")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get supplier count", e);
        }
    }

    public void loadWarehouses(JComboBox<String> warehouseDropdown, int pageNumber, int pageSize) throws DatabaseException {
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT id, name FROM Warehouses ORDER BY name LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            warehouseDropdown.removeAllItems();
            while (rs.next()) {
                int id = rs.getInt("id");
                String name = rs.getString("name");
                warehouseCache.put(id, name);
                warehouseDropdown.addItem(id + " - " + name);
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to load warehouses", e);
        }
    }

    public int getWarehouseCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM Warehouses")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get warehouse count", e);
        }
    }

    public LoadingCache<Integer, String> getCustomerCache() { return customerCache; }
    public LoadingCache<Integer, Product> getProductCache() { return productCache; }
    public LoadingCache<Integer, String> getWarehouseCache() { return warehouseCache; }
    public LoadingCache<Integer, String> getSupplierCache() { return supplierCache; }

    private String fetchCustomerName(Integer id) {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT name FROM Customers WHERE id = ?")) {
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            return rs.next() ? rs.getString("name") : null;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to fetch customer name for ID: " + id, e);
        }
    }

    private Product fetchProduct(Integer id) {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT name, sellingPrice, costPrice, unit FROM Products WHERE id = ?")) {
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return new Product(rs.getString("name"), rs.getDouble("sellingPrice"), rs.getDouble("costPrice"), rs.getString("unit"));
            return null;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to fetch product for ID: " + id, e);
        }
    }

    private String fetchWarehouseName(Integer id) {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT name FROM Warehouses WHERE id = ?")) {
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            return rs.next() ? rs.getString("name") : null;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to fetch warehouse name for ID: " + id, e);
        }
    }

    private String fetchSupplierName(Integer id) {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT name FROM Suppliers WHERE id = ?")) {
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            return rs.next() ? rs.getString("name") : null;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to fetch supplier name for ID: " + id, e);
        }
    }

    public void addCustomer(String name, String contact, String email, String address) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("INSERT INTO Customers (name, contact, email, address) VALUES (?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS)) {
            stmt.setString(1, name);
            stmt.setString(2, contact);
            stmt.setString(3, email);
            stmt.setString(4, address);
            stmt.executeUpdate();
            ResultSet rs = stmt.getGeneratedKeys();
            if (rs.next()) customerCache.put(rs.getInt(1), name);
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to add customer: " + name, e);
        }
    }

    public void updateCustomer(int id, String name, String contact, String email, String address) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("UPDATE Customers SET name = ?, contact = ?, email = ?, address = ? WHERE id = ?")) {
            stmt.setString(1, name);
            stmt.setString(2, contact);
            stmt.setString(3, email);
            stmt.setString(4, address);
            stmt.setInt(5, id);
            stmt.executeUpdate();
            customerCache.put(id, name);
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to update customer: " + id, e);
        }
    }

    public void addSupplier(String name, String contact, String email, String address) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("INSERT INTO Suppliers (name, contact, email, address) VALUES (?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS)) {
            stmt.setString(1, name);
            stmt.setString(2, contact);
            stmt.setString(3, email);
            stmt.setString(4, address);
            stmt.executeUpdate();
            ResultSet rs = stmt.getGeneratedKeys();
            if (rs.next()) supplierCache.put(rs.getInt(1), name);
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to add supplier: " + name, e);
        }
    }

    public void updateSupplier(int id, String name, String contact, String email, String address) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("UPDATE Suppliers SET name = ?, contact = ?, email = ?, address = ? WHERE id = ?")) {
            stmt.setString(1, name);
            stmt.setString(2, contact);
            stmt.setString(3, email);
            stmt.setString(4, address);
            stmt.setInt(5, id);
            stmt.executeUpdate();
            supplierCache.put(id, name);
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to update supplier: " + id, e);
        }
    }

    public void addWarehouse(String name) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("INSERT INTO Warehouses (name) VALUES (?)", Statement.RETURN_GENERATED_KEYS)) {
            stmt.setString(1, name);
            stmt.executeUpdate();
            ResultSet rs = stmt.getGeneratedKeys();
            if (rs.next()) warehouseCache.put(rs.getInt(1), name);
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to add warehouse: " + name, e);
        }
    }

    public void addProduct(String name, double sellingPrice, double costPrice, String unit) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("INSERT INTO Products (name, sellingPrice, costPrice, unit) VALUES (?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS)) {
            stmt.setString(1, name);
            stmt.setDouble(2, sellingPrice);
            stmt.setDouble(3, costPrice);
            stmt.setString(4, unit);
            stmt.executeUpdate();
            ResultSet rs = stmt.getGeneratedKeys();
            if (rs.next()) productCache.put(rs.getInt(1), new Product(name, sellingPrice, costPrice, unit));
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to add product: " + name, e);
        }
    }

    public String generateInvoiceId(String prefix) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT id FROM Invoices WHERE id LIKE ? ORDER BY CAST(SUBSTRING(id, ?) AS UNSIGNED) DESC LIMIT 1 FOR UPDATE")) {
            stmt.setString(1, prefix + "-%");
            stmt.setInt(2, prefix.length() + 2);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                String lastId = rs.getString("id");
                int number = Integer.parseInt(lastId.substring(prefix.length() + 1)) + 1;
                return String.format("%s-%05d", prefix, number);
            }
            return String.format("%s-00001", prefix);
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to generate invoice ID", e);
        }
    }

    public InvoiceLineItem addLineItem(int productId, int warehouseId, int quantity, String unit, double discount, double fixedDiscount, double taxRate, String currency, boolean isPurchase) throws DatabaseException {
        Product product = productCache.get(productId);
        if (product == null) throw new DataProcessingException("Product not found: " + productId, null);

        double unitPrice = isPurchase ? product.getCostPrice() : product.getSellingPrice();
        double discountedPrice = unitPrice * (1 - discount / 100) - fixedDiscount;
        double totalPrice = discountedPrice * quantity;
        double totalTax = totalPrice * (taxRate / 100);
        double unitCost = product.getCostPrice();
        double totalCost = unitCost * quantity;

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO InvoiceLineItems (productId, warehouseId, quantity, unit, unitPrice, totalPrice, unitCost, totalCost, discount, fixedDiscount, taxRate, totalTax, currency) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                 Statement.RETURN_GENERATED_KEYS)) {
            stmt.setInt(1, productId);
            stmt.setInt(2, warehouseId);
            stmt.setInt(3, quantity);
            stmt.setString(4, unit);
            stmt.setDouble(5, unitPrice);
            stmt.setDouble(6, totalPrice);
            stmt.setDouble(7, unitCost);
            stmt.setDouble(8, totalCost);
            stmt.setDouble(9, discount);
            stmt.setDouble(10, fixedDiscount);
            stmt.setDouble(11, taxRate);
            stmt.setDouble(12, totalTax);
            stmt.setString(13, currency);
            stmt.executeUpdate();

            ResultSet keys = stmt.getGeneratedKeys();
            if (keys.next()) return new InvoiceLineItem(keys.getInt(1), productId, warehouseId, quantity, unit, unitPrice, totalPrice, unitCost, totalCost, discount, fixedDiscount, taxRate, totalTax, currency);
            return null;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to add line item for product: " + productId, e);
        }
    }

    public void saveInvoice(Integer customerId, String invoiceType, String date, double totalAmount, double totalTax, String currency,
                            List<InvoiceLineItem> lineItems, String invoiceId, String paymentCurrency, String paymentInstructions,
                            String paymentTerm, String deliveryStatus, String notes, double exchangeRate, double invoiceDiscount,
                            double invoiceFixedDiscount, double invoiceTaxRate, double shippingCharge, String logoPath,
                            Map<String, String> customFields) throws DatabaseException {
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            String finalInvoiceId = invoiceId != null ? invoiceId : generateInvoiceId(invoiceType.substring(0, 3).toUpperCase());
            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO Invoices (id, customerId, type, date, totalAmount, totalTax, currency, paymentCurrency, paymentInstructions, paymentTerm, deliveryStatus, notes, exchangeRate, invoiceDiscount, invoiceFixedDiscount, invoiceTaxRate, shippingCharge, logoPath, customFields) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")) {
                stmt.setString(1, finalInvoiceId);
                stmt.setObject(2, customerId, Types.INTEGER);
                stmt.setString(3, invoiceType.toUpperCase());
                stmt.setString(4, date);
                stmt.setDouble(5, totalAmount);
                stmt.setDouble(6, totalTax);
                stmt.setString(7, currency);
                stmt.setString(8, paymentCurrency);
                stmt.setString(9, paymentInstructions);
                stmt.setString(10, paymentTerm);
                stmt.setString(11, deliveryStatus);
                stmt.setString(12, notes);
                stmt.setDouble(13, exchangeRate);
                stmt.setDouble(14, invoiceDiscount);
                stmt.setDouble(15, invoiceFixedDiscount);
                stmt.setDouble(16, invoiceTaxRate);
                stmt.setDouble(17, shippingCharge);
                stmt.setString(18, logoPath);
                stmt.setString(19, objectMapper.writeValueAsString(customFields));
                stmt.executeUpdate();
            } catch (SQLException e) {
                throw new DataProcessingException("Failed to insert invoice: " + finalInvoiceId, e);
            }

            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO InvoiceLineItems (invoiceId, productId, warehouseId, quantity, unit, unitPrice, totalPrice, unitCost, totalCost, discount, fixedDiscount, taxRate, totalTax, currency) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")) {
                for (int i = 0; i < lineItems.size(); i++) {
                    InvoiceLineItem item = lineItems.get(i);
                    stmt.setString(1, finalInvoiceId);
                    stmt.setInt(2, item.getProductId());
                    stmt.setInt(3, item.getWarehouseId());
                    stmt.setInt(4, item.getQuantity());
                    stmt.setString(5, item.getUnit());
                    stmt.setDouble(6, item.getUnitPrice());
                    stmt.setDouble(7, item.getTotalPrice());
                    stmt.setDouble(8, item.getUnitCost());
                    stmt.setDouble(9, item.getTotalCost());
                    stmt.setDouble(10, item.getDiscount());
                    stmt.setDouble(11, item.getFixedDiscount());
                    stmt.setDouble(12, item.getTaxRate());
                    stmt.setDouble(13, item.getTotalTax());
                    stmt.setString(14, item.getCurrency());
                    stmt.addBatch();

                    if (i % 1000 == 0 || i == lineItems.size() - 1) {
                        stmt.executeBatch();
                    }
                }
            } catch (SQLException e) {
                throw new DataProcessingException("Failed to insert line items for invoice: " + finalInvoiceId, e);
            }

            updateInvoiceTransactions(conn, finalInvoiceId, customerId, totalAmount, invoiceType, lineItems);
            conn.commit();
        } catch (SQLException | com.fasterxml.jackson.core.JsonProcessingException e) {
            try (Connection conn = dataSource.getConnection()) {
                conn.rollback();
            } catch (SQLException rollbackEx) {
                throw new DataProcessingException("Rollback failed after save invoice error", rollbackEx);
            }
            throw new DataProcessingException("Failed to save invoice", e);
        }
    }

    public void updateInvoice(String invoiceId, Integer customerId, String invoiceType, String date, double totalAmount, double totalTax, String currency,
                              List<InvoiceLineItem> lineItems, String paymentCurrency, String paymentInstructions, String paymentTerm,
                              String deliveryStatus, String notes, double exchangeRate, double invoiceDiscount, double invoiceFixedDiscount,
                              double invoiceTaxRate, double shippingCharge, String logoPath, Map<String, String> customFields) throws DatabaseException {
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            InvoiceDetails original = loadInvoiceDetails(invoiceId);
            if (original == null) throw new DataProcessingException("Invoice not found: " + invoiceId, null);

            try (PreparedStatement stmt = conn.prepareStatement(
                "UPDATE Invoices SET customerId = ?, type = ?, date = ?, totalAmount = ?, totalTax = ?, currency = ?, paymentCurrency = ?, paymentInstructions = ?, paymentTerm = ?, deliveryStatus = ?, notes = ?, exchangeRate = ?, invoiceDiscount = ?, invoiceFixedDiscount = ?, invoiceTaxRate = ?, shippingCharge = ?, logoPath = ?, customFields = ? WHERE id = ?")) {
                stmt.setObject(1, customerId, Types.INTEGER);
                stmt.setString(2, invoiceType.toUpperCase());
                stmt.setString(3, date);
                stmt.setDouble(4, totalAmount);
                stmt.setDouble(5, totalTax);
                stmt.setString(6, currency);
                stmt.setString(7, paymentCurrency);
                stmt.setString(8, paymentInstructions);
                stmt.setString(9, paymentTerm);
                stmt.setString(10, deliveryStatus);
                stmt.setString(11, notes);
                stmt.setDouble(12, exchangeRate);
                stmt.setDouble(13, invoiceDiscount);
                stmt.setDouble(14, invoiceFixedDiscount);
                stmt.setDouble(15, invoiceTaxRate);
                stmt.setDouble(16, shippingCharge);
                stmt.setString(17, logoPath);
                stmt.setString(18, objectMapper.writeValueAsString(customFields));
                stmt.setString(19, invoiceId);
                stmt.executeUpdate();
            } catch (SQLException e) {
                throw new DataProcessingException("Failed to update invoice: " + invoiceId, e);
            }

            try (PreparedStatement stmt = conn.prepareStatement("DELETE FROM InvoiceLineItems WHERE invoiceId = ?")) {
                stmt.setString(1, invoiceId);
                stmt.executeUpdate();
            }

            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO InvoiceLineItems (invoiceId, productId, warehouseId, quantity, unit, unitPrice, totalPrice, unitCost, totalCost, discount, fixedDiscount, taxRate, totalTax, currency) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")) {
                for (int i = 0; i < lineItems.size(); i++) {
                    InvoiceLineItem item = lineItems.get(i);
                    stmt.setString(1, invoiceId);
                    stmt.setInt(2, item.getProductId());
                    stmt.setInt(3, item.getWarehouseId());
                    stmt.setInt(4, item.getQuantity());
                    stmt.setString(5, item.getUnit());
                    stmt.setDouble(6, item.getUnitPrice());
                    stmt.setDouble(7, item.getTotalPrice());
                    stmt.setDouble(8, item.getUnitCost());
                    stmt.setDouble(9, item.getTotalCost());
                    stmt.setDouble(10, item.getDiscount());
                    stmt.setDouble(11, item.getFixedDiscount());
                    stmt.setDouble(12, item.getTaxRate());
                    stmt.setDouble(13, item.getTotalTax());
                    stmt.setString(14, item.getCurrency());
                    stmt.addBatch();

                    if (i % 1000 == 0 || i == lineItems.size() - 1) {
                        stmt.executeBatch();
                    }
                }
            }

            StringBuilder changes = new StringBuilder();
            if (!Objects.equals(original.getInvoiceType(), invoiceType)) changes.append("Type changed from ").append(original.getInvoiceType()).append(" to ").append(invoiceType).append("; ");
            if (!Objects.equals(original.getCustomerName(), customerId != null ? customerCache.get(customerId) : null)) changes.append("Customer changed from ").append(original.getCustomerName()).append(" to ").append(customerId != null ? customerCache.get(customerId) : "N/A").append("; ");
            if (!Objects.equals(original.getDate(), date)) changes.append("Date changed from ").append(original.getDate()).append(" to ").append(date).append("; ");
            if (original.getTotalAmount() != totalAmount) changes.append("Total Amount changed from ").append(original.getTotalAmount()).append(" to ").append(totalAmount).append("; ");
            if (!Objects.equals(original.getPaymentTerm(), paymentTerm)) changes.append("Payment Term changed from ").append(original.getPaymentTerm()).append(" to ").append(paymentTerm).append("; ");
            if (changes.length() > 0) logInvoiceChange(invoiceId, changes.toString(), "System");

            updateInvoiceTransactions(conn, invoiceId, customerId, totalAmount, invoiceType, lineItems);

            conn.commit();
        } catch (SQLException | com.fasterxml.jackson.core.JsonProcessingException e) {
            try (Connection conn = dataSource.getConnection()) {
                conn.rollback();
            } catch (SQLException rollbackEx) {
                throw new DataProcessingException("Rollback failed after update invoice error", rollbackEx);
            }
            throw new DataProcessingException("Failed to update invoice: " + invoiceId, e);
        }
    }

    private void updateInvoiceTransactions(Connection conn, String invoiceId, Integer customerId, double totalAmount, String invoiceType, List<InvoiceLineItem> lineItems) throws SQLException {
        try (PreparedStatement stmt = conn.prepareStatement("DELETE FROM CustomerDebits WHERE description = ?")) {
            stmt.setString(1, "Invoice #" + invoiceId);
            stmt.executeUpdate();
        }
        try (PreparedStatement stmt = conn.prepareStatement("DELETE FROM CustomerCredits WHERE description = ?")) {
            stmt.setString(1, "Return Invoice #" + invoiceId);
            stmt.executeUpdate();
        }
        try (PreparedStatement stmt = conn.prepareStatement("DELETE FROM CashTransactions WHERE description LIKE ?")) {
            stmt.setString(1, "%Invoice #" + invoiceId + "%");
            stmt.executeUpdate();
        }

        switch (invoiceType.toUpperCase()) {
            case "SALE":
                if (customerId != null) {
                    try (PreparedStatement stmt = conn.prepareStatement(
                        "INSERT INTO CustomerDebits (customerId, amount, description, date) VALUES (?, ?, ?, NOW())")) {
                        stmt.setInt(1, customerId);
                        stmt.setDouble(2, totalAmount);
                        stmt.setString(3, "Invoice #" + invoiceId);
                        stmt.executeUpdate();
                    }
                }
                double totalCostSale = lineItems.stream().mapToDouble(InvoiceLineItem::getTotalCost).sum();
                try (PreparedStatement stmt = conn.prepareStatement(
                    "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'IN', 'Sales', NOW()), (?, ?, 'OUT', 'COGS', NOW())")) {
                    stmt.setString(1, "Invoice #" + invoiceId + " Sales");
                    stmt.setDouble(2, totalAmount);
                    stmt.setString(3, "Invoice #" + invoiceId + " COGS");
                    stmt.setDouble(4, totalCostSale);
                    stmt.executeBatch();
                }
                for (InvoiceLineItem item : lineItems) updateInventory(conn, Collections.singletonList(item), item.getWarehouseId(), "OUT");
                break;

            case "PURCHASE":
            case "IMPORT":
                try (PreparedStatement stmt = conn.prepareStatement(
                    "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'OUT', ?, NOW())")) {
                    stmt.setString(1, invoiceType + " Invoice #" + invoiceId);
                    stmt.setDouble(2, totalAmount);
                    stmt.setString(3, invoiceType.equals("PURCHASE") ? "Purchases" : "Imports");
                    stmt.executeUpdate();
                }
                for (InvoiceLineItem item : lineItems) updateInventory(conn, Collections.singletonList(item), item.getWarehouseId(), "IN");
                break;

            case "SALE_RETURN":
                if (customerId != null) {
                    try (PreparedStatement stmt = conn.prepareStatement(
                        "INSERT INTO CustomerCredits (customerId, amount, description, date) VALUES (?, ?, ?, NOW())")) {
                        stmt.setInt(1, customerId);
                        stmt.setDouble(2, totalAmount);
                        stmt.setString(3, "Return Invoice #" + invoiceId);
                        stmt.executeUpdate();
                    }
                }
                try (PreparedStatement stmt = conn.prepareStatement(
                    "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'OUT', 'Sales Returns', NOW())")) {
                    stmt.setString(1, "Return Invoice #" + invoiceId);
                    stmt.setDouble(2, totalAmount);
                    stmt.executeUpdate();
                }
                for (InvoiceLineItem item : lineItems) updateInventory(conn, Collections.singletonList(item), item.getWarehouseId(), "IN");
                break;

            case "PURCHASE_RETURN":
                try (PreparedStatement stmt = conn.prepareStatement(
                    "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'IN', 'Purchase Returns', NOW())")) {
                    stmt.setString(1, "Return Invoice #" + invoiceId);
                    stmt.setDouble(2, totalAmount);
                    stmt.executeUpdate();
                }
                for (InvoiceLineItem item : lineItems) updateInventory(conn, Collections.singletonList(item), item.getWarehouseId(), "OUT");
                break;
        }
    }

    private void updateInventory(Connection conn, List<InvoiceLineItem> lineItems, int warehouseId, String type) throws SQLException {
        try (PreparedStatement stmt = conn.prepareStatement(
            "INSERT INTO InventoryTransactions (productId, warehouseId, quantity, type, date, cost) VALUES (?, ?, ?, ?, NOW(), ?)")) {
            try (PreparedStatement updateStmt = conn.prepareStatement(
                type.equals("IN") ?
                "INSERT INTO Inventory (productId, warehouseId, quantity) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE quantity = quantity + ?" :
                "UPDATE Inventory SET quantity = GREATEST(quantity - ?, 0) WHERE productId = ? AND warehouseId = ?")) {
                for (InvoiceLineItem item : lineItems) {
                    stmt.setInt(1, item.getProductId());
                    stmt.setInt(2, warehouseId);
                    stmt.setInt(3, item.getQuantity());
                    stmt.setString(4, type);
                    stmt.setDouble(5, item.getTotalCost());
                    stmt.addBatch();

                    updateStmt.setInt(1, item.getQuantity());
                    updateStmt.setInt(2, item.getProductId());
                    updateStmt.setInt(3, warehouseId);
                    if (type.equals("IN")) updateStmt.setInt(4, item.getQuantity());
                    updateStmt.addBatch();
                }
                stmt.executeBatch();
                updateStmt.executeBatch();
            }
        }
    }

    public InvoiceDetails loadInvoiceDetails(String invoiceId) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT i.*, COALESCE(c.name, s.name) AS customerName, " +
                 "COALESCE(SUM(d.amount), 0) - COALESCE(SUM(cr.amount), 0) AS debitCredit " +
                 "FROM Invoices i " +
                 "LEFT JOIN Customers c ON i.customerId = c.id " +
                 "LEFT JOIN Suppliers s ON i.customerId = s.id " +
                 "LEFT JOIN CustomerDebits d ON i.customerId = d.customerId " +
                 "LEFT JOIN CustomerCredits cr ON i.customerId = cr.customerId " +
                 "WHERE i.id = ? " +
                 "GROUP BY i.id, c.name, s.name")) {
            stmt.setString(1, invoiceId);
            ResultSet rs = stmt.executeQuery();

            if (rs.next()) {
                List<InvoiceLineItem> lineItems = loadLineItems(invoiceId);
                double exchangeRate = rs.getDouble("exchangeRate");
                double usdTotal = 0.0, localTotal = 0.0, totalTax = 0.0;
                for (InvoiceLineItem item : lineItems) {
                    if ("USD".equals(item.getCurrency())) {
                        usdTotal += item.getTotalPrice();
                        localTotal += item.getTotalPrice() * exchangeRate;
                        totalTax += item.getTotalTax();
                    } else {
                        localTotal += item.getTotalPrice();
                        usdTotal += item.getTotalPrice() / exchangeRate;
                        totalTax += item.getTotalTax() / exchangeRate;
                    }
                }
                double invoiceDiscount = rs.getDouble("invoiceDiscount");
                double invoiceFixedDiscount = rs.getDouble("invoiceFixedDiscount");
                double invoiceTaxRate = rs.getDouble("invoiceTaxRate");
                double shippingCharge = rs.getDouble("shippingCharge");
                double discountedTotal = usdTotal * (1 - invoiceDiscount / 100) - invoiceFixedDiscount;
                usdTotal = discountedTotal * (1 + invoiceTaxRate / 100) + shippingCharge;
                localTotal = usdTotal * exchangeRate;
                double totalDebit = rs.getDouble("debitCredit");
                Map<String, String> customFields = rs.getString("customFields") != null ?
                    objectMapper.readValue(rs.getString("customFields"), Map.class) : new HashMap<>();
                return new InvoiceDetails(
                    rs.getString("id"),
                    rs.getString("type"),
                    rs.getString("customerName"),
                    null,
                    rs.getString("date"),
                    usdTotal,
                    totalDebit,
                    totalDebit,
                    rs.getString("currency"),
                    rs.getString("paymentTerm"),
                    rs.getString("deliveryStatus"),
                    rs.getString("paymentInstructions"),
                    rs.getString("notes"),
                    lineItems,
                    usdTotal,
                    localTotal,
                    totalTax,
                    invoiceDiscount,
                    invoiceFixedDiscount,
                    invoiceTaxRate,
                    shippingCharge,
                    rs.getString("logoPath"),
                    exchangeRate,
                    customFields
                );
            }
            return null;
        } catch (SQLException | com.fasterxml.jackson.core.JsonProcessingException e) {
            throw new DataProcessingException("Failed to load invoice details: " + invoiceId, e);
        }
    }

    private List<InvoiceLineItem> loadLineItems(String invoiceId) throws DatabaseException {
        List<InvoiceLineItem> lineItems = new ArrayList<>();
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT * FROM InvoiceLineItems WHERE invoiceId = ? ORDER BY id")) {
            stmt.setString(1, invoiceId);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                lineItems.add(new InvoiceLineItem(
                    rs.getInt("id"),
                    rs.getInt("productId"),
                    rs.getInt("warehouseId"),
                    rs.getInt("quantity"),
                    rs.getString("unit"),
                    rs.getDouble("unitPrice"),
                    rs.getDouble("totalPrice"),
                    rs.getDouble("unitCost"),
                    rs.getDouble("totalCost"),
                    rs.getDouble("discount"),
                    rs.getDouble("fixedDiscount"),
                    rs.getDouble("taxRate"),
                    rs.getDouble("totalTax"),
                    rs.getString("currency")
                ));
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to load line items for invoice: " + invoiceId, e);
        }
        return lineItems;
    }

    public void saveRecurringInvoice(String invoiceId, String frequencyType, int frequencyInterval, String nextDate, String endDate) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO RecurringInvoices (invoiceId, frequencyType, frequencyInterval, nextDate, endDate) VALUES (?, ?, ?, ?, ?)")) {
            stmt.setString(1, invoiceId);
            stmt.setString(2, frequencyType);
            stmt.setInt(3, frequencyInterval);
            stmt.setString(4, nextDate);
            stmt.setString(5, endDate);
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to save recurring invoice: " + invoiceId, e);
        }
    }

    public List<RecurringInvoice> getRecurringInvoices(int pageNumber, int pageSize) throws DatabaseException {
        List<RecurringInvoice> invoices = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT * FROM RecurringInvoices ORDER BY nextDate LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                invoices.add(new RecurringInvoice(
                    rs.getInt("id"),
                    rs.getString("invoiceId"),
                    rs.getString("frequencyType"),
                    rs.getInt("frequencyInterval"),
                    rs.getString("nextDate"),
                    rs.getString("endDate"),
                    rs.getString("lastGenerated")
                ));
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get recurring invoices", e);
        }
        return invoices;
    }

    public int getRecurringInvoiceCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM RecurringInvoices")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get recurring invoice count", e);
        }
    }

    public void processRecurringInvoices() throws DatabaseException {
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT i.*, ri.id AS recurringId, ri.frequencyType, ri.frequencyInterval, ri.nextDate, ri.endDate " +
                "FROM RecurringInvoices ri " +
                "JOIN Invoices i ON ri.invoiceId = i.id " +
                "WHERE ri.nextDate <= CURDATE() AND (ri.endDate IS NULL OR ri.endDate >= CURDATE()) FOR UPDATE")) {
                ResultSet rs = stmt.executeQuery();
                List<RecurringInvoiceData> invoices = new ArrayList<>();
                while (rs.next()) {
                    invoices.add(new RecurringInvoiceData(rs));
                }

                Flux.fromIterable(invoices)
                    .onBackpressureBuffer(10000)
                    .publishOn(Schedulers.boundedElastic())
                    .doOnNext(data -> processSingleRecurringInvoice(conn, data))
                    .doOnError(e -> {
                        try {
                            conn.rollback();
                        } catch (SQLException rollbackEx) {
                            LOGGER.error("Rollback failed", rollbackEx);
                        }
                    })
                    .blockLast();

                conn.commit();
            } catch (SQLException e) {
                conn.rollback();
                throw new DataProcessingException("Failed to process recurring invoices", e);
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to process recurring invoices", e);
        }
    }

    private void processSingleRecurringInvoice(Connection conn, RecurringInvoiceData data) {
        try {
            String newInvoiceId = generateInvoiceId(data.type.substring(0, 3));
            try (PreparedStatement insertStmt = conn.prepareStatement(
                "INSERT INTO Invoices (id, customerId, type, date, totalAmount, totalTax, currency, paymentCurrency, paymentInstructions, paymentTerm, deliveryStatus, notes, exchangeRate, invoiceDiscount, invoiceFixedDiscount, invoiceTaxRate, shippingCharge, logoPath, customFields) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")) {
                insertStmt.setString(1, newInvoiceId);
                insertStmt.setObject(2, data.customerId, Types.INTEGER);
                insertStmt.setString(3, data.type);
                insertStmt.setString(4, new java.text.SimpleDateFormat("yyyy-MM-dd").format(new java.util.Date()));
                insertStmt.setDouble(5, data.totalAmount);
                insertStmt.setDouble(6, data.totalTax);
                insertStmt.setString(7, data.currency);
                insertStmt.setString(8, data.paymentCurrency);
                insertStmt.setString(9, data.paymentInstructions);
                insertStmt.setString(10, data.paymentTerm);
                insertStmt.setString(11, "DRAFT");
                insertStmt.setString(12, data.notes);
                insertStmt.setDouble(13, data.exchangeRate);
                insertStmt.setDouble(14, data.invoiceDiscount);
                insertStmt.setDouble(15, data.invoiceFixedDiscount);
                insertStmt.setDouble(16, data.invoiceTaxRate);
                insertStmt.setDouble(17, data.shippingCharge);
                insertStmt.setString(18, data.logoPath);
                insertStmt.setString(19, objectMapper.writeValueAsString(data.customFields));
                insertStmt.executeUpdate();
            }

            List<InvoiceLineItem> lineItems = loadLineItems(data.invoiceId);
            for (InvoiceLineItem item : lineItems) {
                try (PreparedStatement lineStmt = conn.prepareStatement(
                    "INSERT INTO InvoiceLineItems (invoiceId, productId, warehouseId, quantity, unit, unitPrice, totalPrice, unitCost, totalCost, discount, fixedDiscount, taxRate, totalTax, currency) " +
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")) {
                    lineStmt.setString(1, newInvoiceId);
                    lineStmt.setInt(2, item.getProductId());
                    lineStmt.setInt(3, item.getWarehouseId());
                    lineStmt.setInt(4, item.getQuantity());
                    lineStmt.setString(5, item.getUnit());
                    lineStmt.setDouble(6, item.getUnitPrice());
                    lineStmt.setDouble(7, item.getTotalPrice());
                    lineStmt.setDouble(8, item.getUnitCost());
                    lineStmt.setDouble(9, item.getTotalCost());
                    lineStmt.setDouble(10, item.getDiscount());
                    lineStmt.setDouble(11, item.getFixedDiscount());
                    lineStmt.setDouble(12, item.getTaxRate());
                    lineStmt.setDouble(13, item.getTotalTax());
                    lineStmt.setString(14, item.getCurrency());
                    lineStmt.executeUpdate();
                }
            }

            updateInvoiceTransactions(conn, newInvoiceId, data.customerId, data.totalAmount, data.type, lineItems);

            try (PreparedStatement updateStmt = conn.prepareStatement(
                "UPDATE RecurringInvoices SET nextDate = ?, lastGenerated = CURDATE() WHERE id = ?")) {
                LocalDate nextDate = LocalDate.parse(data.nextDate);
                switch (data.frequencyType.toUpperCase()) {
                    case "DAILY": nextDate = nextDate.plusDays(data.frequencyInterval); break;
                    case "WEEKLY": nextDate = nextDate.plusWeeks(data.frequencyInterval); break;
                    case "BIWEEKLY": nextDate = nextDate.plusWeeks(2 * data.frequencyInterval); break;
                    case "MONTHLY": nextDate = nextDate.plusMonths(data.frequencyInterval); break;
                    case "QUARTERLY": nextDate = nextDate.plusMonths(3 * data.frequencyInterval); break;
                    case "YEARLY": nextDate = nextDate.plusYears(data.frequencyInterval); break;
                }
                updateStmt.setString(1, nextDate.toString());
                updateStmt.setInt(2, data.recurringId);
                updateStmt.executeUpdate();
            }
        } catch (SQLException | DatabaseException | com.fasterxml.jackson.core.JsonProcessingException e) {
            throw new DataProcessingException("Failed to process recurring invoice: " + data.invoiceId, e);
        }
    }

    private static class RecurringInvoiceData {
        final String invoiceId;
        final Integer customerId;
        final String type;
        final double totalAmount;
        final double totalTax;
        final String currency;
        final String paymentCurrency;
        final String paymentInstructions;
        final String paymentTerm;
        final String deliveryStatus;
        final String notes;
        final double exchangeRate;
        final double invoiceDiscount;
        final double invoiceFixedDiscount;
        final double invoiceTaxRate;
        final double shippingCharge;
        final String logoPath;
        final Map<String, String> customFields;
        final int recurringId;
        final String frequencyType;
        final int frequencyInterval;
        final String nextDate;

        RecurringInvoiceData(ResultSet rs) throws SQLException, com.fasterxml.jackson.core.JsonProcessingException {
            this.invoiceId = rs.getString("id");
            this.customerId = rs.getObject("customerId") != null ? rs.getInt("customerId") : null;
            this.type = rs.getString("type");
            this.totalAmount = rs.getDouble("totalAmount");
            this.totalTax = rs.getDouble("totalTax");
            this.currency = rs.getString("currency");
            this.paymentCurrency = rs.getString("paymentCurrency");
            this.paymentInstructions = rs.getString("paymentInstructions");
            this.paymentTerm = rs.get<|control695|>("paymentTerm");
            this.deliveryStatus = rs.getString("deliveryStatus");
            this.notes = rs.getString("notes");
            this.exchangeRate = rs.getDouble("exchangeRate");
            this.invoiceDiscount = rs.getDouble("invoiceDiscount");
            this.invoiceFixedDiscount = rs.getDouble("invoiceFixedDiscount");
            this.invoiceTaxRate = rs.getDouble("invoiceTaxRate");
            this.shippingCharge = rs.getDouble("shippingCharge");
            this.logoPath = rs.getString("logoPath");
            this.customFields = rs.getString("customFields") != null ?
                objectMapper.readValue(rs.getString("customFields"), Map.class) : new HashMap<>();
            this.recurringId = rs.getInt("recurringId");
            this.frequencyType = rs.getString("frequencyType");
            this.frequencyInterval = rs.getInt("frequencyInterval");
            this.nextDate = rs.getString("nextDate");
        }
    }

    public List<String> getOverduePayments(int pageNumber, int pageSize) throws DatabaseException {
        List<String> overduePayments = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT i.id, i.totalAmount, c.name " +
                 "FROM Invoices i " +
                 "JOIN Customers c ON i.customerId = c.id " +
                 "WHERE i.type = 'SALE' AND i.date < CURDATE() AND i.totalAmount > 0 AND i.deliveryStatus != 'PAID' " +
                 "LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                overduePayments.add("Invoice ID: " + rs.getString("id") + ", Customer: " + rs.getString("name") + ", Amount: " + rs.getDouble("totalAmount") + " USD");
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get overdue payments", e);
        }
        return overduePayments;
    }

    public int getOverduePaymentCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT COUNT(*) FROM Invoices i " +
                 "JOIN Customers c ON i.customerId = c.id " +
                 "WHERE i.type = 'SALE' AND i.date < CURDATE() AND i.totalAmount > 0 AND i.deliveryStatus != 'PAID'")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get overdue payment count", e);
        }
    }

    public void markPaymentReceived(String customerName, double amount, String currency, double exchangeRate, String invoiceId) throws DatabaseException {
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            int customerId;
            try (PreparedStatement stmt = conn.prepareStatement("SELECT id FROM Customers WHERE name = ?")) {
                stmt.setString(1, customerName);
                ResultSet rs = stmt.executeQuery();
                if (!rs.next()) throw new DataProcessingException("Customer not found: " + customerName, null);
                customerId = rs.getInt("id");
            }

            double currentDebitUSD = getCustomerDebit(customerId);
            double paymentInUSD = currency.equals("USD") ? amount : amount / exchangeRate;
            if (paymentInUSD > currentDebitUSD && invoiceId != null) {
                throw new DataProcessingException("Payment amount (" + paymentInUSD + " USD) exceeds customer debit (" + currentDebitUSD + " USD)", null);
            }

            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO Payments (customerId, invoiceId, amount, paymentDate, currency, exchangeRate) VALUES (?, ?, ?, NOW(), ?, ?)")) {
                stmt.setInt(1, customerId);
                stmt.setString(2, invoiceId);
                stmt.setDouble(3, amount);
                stmt.setString(4, currency);
                stmt.setDouble(5, exchangeRate);
                stmt.executeUpdate();
            }

            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO CustomerCredits (customerId, amount, description, date) VALUES (?, ?, ?, NOW())")) {
                stmt.setInt(1, customerId);
                stmt.setDouble(2, paymentInUSD);
                stmt.setString(3, invoiceId != null ? "Payment for Invoice #" + invoiceId : "General Payment");
                stmt.executeUpdate();
            }

            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'IN', 'Payments', NOW())")) {
                stmt.setString(1, "Payment from " + customerName + (invoiceId != null ? " for Invoice #" + invoiceId : " (General)") + " in " + currency);
                stmt.setDouble(2, paymentInUSD);
                stmt.executeUpdate();
            }

            if (invoiceId != null) {
                try (PreparedStatement stmt = conn.prepareStatement(
                    "UPDATE Invoices SET deliveryStatus = 'PAID' WHERE id = ?")) {
                    stmt.setString(1, invoiceId);
                    stmt.executeUpdate();
                }
            }

            conn.commit();
        } catch (SQLException e) {
            try (Connection conn = dataSource.getConnection()) {
                conn.rollback();
            } catch (SQLException rollbackEx) {
                throw new DataProcessingException("Rollback failed after marking payment", rollbackEx);
            }
            throw new DataProcessingException("Failed to mark payment received for: " + customerName, e);
        }
    }

    public double getCustomerDebit(int customerId) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT COALESCE(SUM(d.amount), 0) - COALESCE(SUM(c.amount), 0) AS debitCredit " +
                 "FROM Customers cu " +
                 "LEFT JOIN CustomerDebits d ON cu.id = d.customerId " +
                 "LEFT JOIN CustomerCredits c ON cu.id = c.customerId " +
                 "WHERE cu.id = ?")) {
            stmt.setInt(1, customerId);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getDouble("debitCredit");
            return 0.0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get customer debit for ID: " + customerId, e);
        }
    }

    public void addInventoryItem(int productId, int warehouseId, int quantity) throws DatabaseException {
        Product product = productCache.get(productId);
        if (product == null) throw new DataProcessingException("Product not found in cache: " + productId, null);
        double cost = product.getCostPrice() * quantity;

        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO Inventory (productId, warehouseId, quantity) " +
                "VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE quantity = quantity + ?")) {
                stmt.setInt(1, productId);
                stmt.setInt(2, warehouseId);
                stmt.setInt(3, quantity);
                stmt.setInt(4, quantity);
                stmt.executeUpdate();
            }

            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO InventoryTransactions (productId, warehouseId, quantity, type, date, cost) " +
                "VALUES (?, ?, ?, 'IN', NOW(), ?)")) {
                stmt.setInt(1, productId);
                stmt.setInt(2, warehouseId);
                stmt.setInt(3, quantity);
                stmt.setDouble(4, cost);
                stmt.executeUpdate();
            }

            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO CashTransactions (description, amount, type, category, date) " +
                "VALUES (?, ?, 'OUT', 'Inventory Purchase', NOW())")) {
                stmt.setString(1, "Inventory Purchase for Product #" + productId);
                stmt.setDouble(2, cost);
                stmt.executeUpdate();
            }
            conn.commit();
        } catch (SQLException e) {
            try (Connection conn = dataSource.getConnection()) {
                conn.rollback();
            } catch (SQLException rollbackEx) {
                throw new DataProcessingException("Rollback failed after adding inventory item", rollbackEx);
            }
            throw new DataProcessingException("Failed to add inventory item for product: " + productId, e);
        }
    }

    public List<InventoryItem> getInventoryItems(int pageNumber, int pageSize) throws DatabaseException {
        TIntList productIds = new TIntArrayList();
        TIntList warehouseIds = new TIntArrayList();
        TIntList quantities = new TIntArrayList();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT productId, warehouseId, quantity FROM Inventory ORDER BY productId, warehouseId LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                productIds.add(rs.getInt("productId"));
                warehouseIds.add(rs.getInt("warehouseId"));
                quantities.add(rs.getInt("quantity"));
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get inventory items", e);
        }
        List<InventoryItem> inventoryItems = new ArrayList<>(productIds.size());
        for (int i = 0; i < productIds.size(); i++) {
            inventoryItems.add(new InventoryItem(productIds.get(i), warehouseIds.get(i), quantities.get(i)));
        }
        return inventoryItems;
    }

    public int getInventoryCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM Inventory")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get inventory count", e);
        }
    }

    public void addAttachment(String transactionType, String transactionId, File file) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO Attachments (transactionType, transactionId, fileName, fileSize, uploadDate, content) VALUES (?, ?, ?, ?, NOW(), ?)")) {
            stmt.setString(1, transactionType);
            stmt.setString(2, transactionId);
            stmt.setString(3, file.getName());
            stmt.setLong(4, file.length());
            stmt.setBytes(5, Files.readAllBytes(file.toPath()));
            stmt.executeUpdate();
        } catch (SQLException | java.io.IOException e) {
            throw new DataProcessingException("Failed to add attachment for " + transactionType + ": " + transactionId, e);
        }
    }

    public List<Attachment> getAttachments(String transactionType, String transactionId, int pageNumber, int pageSize) throws DatabaseException {
        List<Attachment> attachments = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT id, fileName, fileSize, uploadDate FROM Attachments WHERE transactionType = ? AND transactionId = ? ORDER BY uploadDate LIMIT ? OFFSET ?")) {
            stmt.setString(1, transactionType);
            stmt.setString(2, transactionId);
            stmt.setInt(3, pageSize);
            stmt.setInt(4, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                attachments.add(new Attachment(
                    rs.getInt("id"),
                    rs.getString("fileName"),
                    rs.getLong("fileSize"),
                    rs.getString("uploadDate")
                ));
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get attachments for " + transactionType + ": " + transactionId, e);
        }
        return attachments;
    }

    public byte[] getAttachmentContent(int attachmentId) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT content FROM Attachments WHERE id = ?")) {
            stmt.setInt(1, attachmentId);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getBytes("content");
            return null;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get attachment content for ID: " + attachmentId, e);
        }
    }

    public int getAttachmentCount(String transactionType, String transactionId) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM Attachments WHERE transactionType = ? AND transactionId = ?")) {
            stmt.setString(1, transactionType);
            stmt.setString(2, transactionId);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get attachment count for " + transactionType + ": " + transactionId, e);
        }
    }

    public void addAdjustment(String type, String description, double amount, Integer accountFrom, Integer accountTo, String date, String currency, double exchangeRate) throws DatabaseException {
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO Adjustments (type, description, amount, accountFrom, accountTo, date, currency, exchangeRate) VALUES (?, ?, ?, ?, ?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS)) {
                stmt.setString(1, type);
                stmt.setString(2, description);
                stmt.setDouble(3, amount);
                stmt.setObject(4, accountFrom, Types.INTEGER);
                stmt.setObject(5, accountTo, Types.INTEGER);
                stmt.setString(6, date);
                stmt.setString(7, currency);
                stmt.setDouble(8, exchangeRate);
                stmt.executeUpdate();
            }

            double amountUSD = currency.equals("USD") ? amount : amount / exchangeRate;
            switch (type) {
                case "BALANCE_TRANSFER":
                    if (accountFrom != null) {
                        try (PreparedStatement stmt = conn.prepareStatement(
                            "INSERT INTO CustomerDebits (customerId, amount, description, date) VALUES (?, ?, ?, ?)")) {
                            stmt.setInt(1, accountFrom);
                            stmt.setDouble(2, amountUSD);
                            stmt.setString(3, description);
                            stmt.setString(4, date);
                                                        stmt.executeUpdate();
                        }
                    }
                    if (accountTo != null) {
                        try (PreparedStatement stmt = conn.prepareStatement(
                            "INSERT INTO CustomerCredits (customerId, amount, description, date) VALUES (?, ?, ?, ?)")) {
                            stmt.setInt(1, accountTo);
                            stmt.setDouble(2, amountUSD);
                            stmt.setString(3, description);
                            stmt.setString(4, date);
                            stmt.executeUpdate();
                        }
                    }
                    break;
                case "INVENTORY_VALUATION":
                    try (PreparedStatement stmt = conn.prepareStatement(
                        "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'OUT', 'Inventory Adjustment', ?)")) {
                        stmt.setString(1, description);
                        stmt.setDouble(2, amountUSD);
                        stmt.setString(3, date);
                        stmt.executeUpdate();
                    }
                    break;
                case "DEFERRED_EXPENSE":
                case "TAX_DUE":
                case "OTHER_PAYMENT":
                    try (PreparedStatement stmt = conn.prepareStatement(
                        "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'OUT', ?, ?)")) {
                        stmt.setString(1, description);
                        stmt.setDouble(2, amountUSD);
                        stmt.setString(3, type.equals("DEFERRED_EXPENSE") ? "Deferred Expenses" : type.equals("TAX_DUE") ? "Taxes" : "Other Payments");
                        stmt.setString(4, date);
                        stmt.executeUpdate();
                    }
                    break;
                case "ACCRUED_REVENUE":
                    if (accountTo != null) {
                        try (PreparedStatement stmt = conn.prepareStatement(
                            "INSERT INTO CustomerDebits (customerId, amount, description, date) VALUES (?, ?, ?, ?)")) {
                            stmt.setInt(1, accountTo);
                            stmt.setDouble(2, amountUSD);
                            stmt.setString(3, description);
                            stmt.setString(4, date);
                            stmt.executeUpdate();
                        }
                    }
                    try (PreparedStatement stmt = conn.prepareStatement(
                        "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'IN', 'Accrued Revenue', ?)")) {
                        stmt.setString(1, description);
                        stmt.setDouble(2, amountUSD);
                        stmt.setString(3, date);
                        stmt.executeUpdate();
                    }
                    break;
            }
            conn.commit();
        } catch (SQLException e) {
            try (Connection conn = dataSource.getConnection()) {
                conn.rollback();
            } catch (SQLException rollbackEx) {
                throw new DataProcessingException("Rollback failed after adding adjustment", rollbackEx);
            }
            throw new DataProcessingException("Failed to add adjustment: " + description, e);
        }
    }

    public List<Adjustment> getAdjustments(int pageNumber, int pageSize) throws DatabaseException {
        List<Adjustment> adjustments = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT * FROM Adjustments ORDER BY date DESC LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                adjustments.add(new Adjustment(
                    rs.getInt("id"),
                    rs.getString("type"),
                    rs.getString("description"),
                    rs.getDouble("amount"),
                    rs.getObject("accountFrom", Integer.class),
                    rs.getObject("accountTo", Integer.class),
                    rs.getString("date"),
                    rs.getString("currency"),
                    rs.getDouble("exchangeRate")
                ));
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get adjustments", e);
        }
        return adjustments;
    }

    public int getAdjustmentCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM Adjustments")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get adjustment count", e);
        }
    }

    public void addExpense(String description, double amount, String currency, String category, String date) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'OUT', ?, ?)")) {
            stmt.setString(1, description);
            stmt.setDouble(2, amount);
            stmt.setString(3, category);
            stmt.setString(4, date);
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to add expense: " + description, e);
        }
    }

    public List<Expense> getExpenses(int pageNumber, int pageSize) throws DatabaseException {
        List<Expense> expenses = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT description, amount, currency, category, date FROM CashTransactions WHERE type = 'OUT' AND category NOT IN ('COGS', 'Sales Returns', 'Inventory Adjustment', 'Deferred Expenses', 'Taxes', 'Other Payments') ORDER BY date DESC LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                expenses.add(new Expense(
                    rs.getString("description"),
                    rs.getDouble("amount"),
                    rs.getString("currency"),
                    rs.getString("category"),
                    rs.getString("date")
                ));
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get expenses", e);
        }
        return expenses;
    }

    public int getExpenseCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT COUNT(*) FROM CashTransactions WHERE type = 'OUT' AND category NOT IN ('COGS', 'Sales Returns', 'Inventory Adjustment', 'Deferred Expenses', 'Taxes', 'Other Payments')")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get expense count", e);
        }
    }

    public void setBudget(String category, double amount) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO Budgets (category, amount) VALUES (?, ?) ON DUPLICATE KEY UPDATE amount = ?")) {
            stmt.setString(1, category);
            stmt.setDouble(2, amount);
            stmt.setDouble(3, amount);
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to set budget for category: " + category, e);
        }
    }

    public double getBudgetLimit(String category) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT amount FROM Budgets WHERE category = ?")) {
            stmt.setString(1, category);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getDouble("amount");
            return 0.0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get budget limit for category: " + category, e);
        }
    }

    public double getTotalExpensesByCategory(String category) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT SUM(amount) as total FROM CashTransactions WHERE type = 'OUT' AND category = ?")) {
            stmt.setString(1, category);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getDouble("total");
            return 0.0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get total expenses for category: " + category, e);
        }
    }

    public double getTotalSales() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT SUM(totalAmount) as total FROM Invoices WHERE type = 'SALE'")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getDouble("total");
            return 0.0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get total sales", e);
        }
    }

    public double getOverdueAmount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT SUM(totalAmount) as total FROM Invoices i " +
                 "JOIN Customers c ON i.customerId = c.id " +
                 "WHERE i.type = 'SALE' AND i.date < CURDATE() AND i.totalAmount > 0 AND i.deliveryStatus != 'PAID'")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getDouble("total");
            return 0.0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get overdue amount", e);
        }
    }

    public double getCashBalance() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT SUM(CASE WHEN type = 'IN' THEN amount ELSE -amount END) as balance FROM CashTransactions")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getDouble("balance");
            return 0.0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get cash balance", e);
        }
    }

    public Map<String, Double> generateCompanyFinancialSummary(String startDate, String endDate) throws DatabaseException {
        Map<String, Double> summary = new LinkedHashMap<>();
        try (Connection conn = dataSource.getConnection()) {
            double totalRevenue = 0.0;
            double totalCogs = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(li.totalPrice) as totalRevenue, SUM(li.totalCost) as totalCogs " +
                "FROM Invoices i " +
                "JOIN InvoiceLineItems li ON i.id = li.invoiceId " +
                "WHERE i.type = 'SALE' AND i.date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) {
                    totalRevenue = rs.getDouble("totalRevenue");
                    totalCogs = rs.getDouble("totalCogs");
                }
            }

            double totalExpenses = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(amount) as totalExpenses " +
                "FROM CashTransactions " +
                "WHERE type = 'OUT' AND category NOT IN ('COGS', 'Sales Returns') AND date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) totalExpenses = rs.getDouble("totalExpenses");
            }
            summary.put("Profit", totalRevenue - totalCogs - totalExpenses);

            double initialCash = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(CASE WHEN type = 'IN' THEN amount ELSE -amount END) as initialCash " +
                "FROM CashTransactions " +
                "WHERE date < ?")) {
                stmt.setString(1, startDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) initialCash = rs.getDouble("initialCash");
            }

            double periodCashInflows = 0.0;
            double periodCashOutflows = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(CASE WHEN type = 'IN' THEN amount ELSE 0 END) as inflows, " +
                "SUM(CASE WHEN type = 'OUT' THEN amount ELSE 0 END) as outflows " +
                "FROM CashTransactions " +
                "WHERE date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) {
                    periodCashInflows = rs.getDouble("inflows");
                    periodCashOutflows = rs.getDouble("outflows");
                }
            }
            summary.put("Cash", initialCash + periodCashInflows - periodCashOutflows);

            double avgInventory = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT AVG(quantity * p.costPrice) as avgInventory " +
                "FROM Inventory i " +
                "JOIN Products p ON i.productId = p.id " +
                "WHERE EXISTS (SELECT 1 FROM InventoryTransactions it WHERE it.productId = i.productId AND it.date BETWEEN ? AND ?)")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) avgInventory = rs.getDouble("avgInventory");
            }
            summary.put("Inventory Turnover", avgInventory > 0 ? totalCogs / avgInventory : 0.0);

            double topCustomerRevenue = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(i.totalAmount) as revenue " +
                "FROM Invoices i " +
                "WHERE i.type = 'SALE' AND i.date BETWEEN ? AND ? " +
                "GROUP BY i.customerId " +
                "ORDER BY revenue DESC LIMIT 1")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) topCustomerRevenue = rs.getDouble("revenue");
            }
            summary.put("Top Customer Revenue", topCustomerRevenue);

            double totalDebits = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(amount) as totalDebits " +
                "FROM CustomerDebits " +
                "WHERE date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) totalDebits = rs.getDouble("totalDebits");
            }
            summary.put("Debits", totalDebits);

            double totalCredits = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(amount) as totalCredits " +
                "FROM CustomerCredits " +
                "WHERE date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) totalCredits = rs.getDouble("totalCredits");
            }
            summary.put("Credits", totalCredits);
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to generate financial summary", e);
        }
        return summary;
    }

    public Map<String, Double> generateCashFlowStatement(String startDate, String endDate) throws DatabaseException {
        Map<String, Double> cashFlow = new LinkedHashMap<>();
        try (Connection conn = dataSource.getConnection()) {
            double cashInflows = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(amount) as inflows " +
                "FROM CashTransactions " +
                "WHERE type = 'IN' AND date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) cashInflows = rs.getDouble("inflows");
            }
            cashFlow.put("Operating Cash Inflows", cashInflows);

            double cashOutflows = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(amount) as outflows " +
                "FROM CashTransactions " +
                "WHERE type = 'OUT' AND date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) cashOutflows = rs.getDouble("outflows");
            }
            cashFlow.put("Operating Cash Outflows", cashOutflows);

            double initialCash = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(CASE WHEN type = 'IN' THEN amount ELSE -amount END) as initialCash " +
                "FROM CashTransactions " +
                "WHERE date < ?")) {
                stmt.setString(1, startDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) initialCash = rs.getDouble("initialCash");
            }
            cashFlow.put("Beginning Cash Balance", initialCash);

            double netCashFlow = cashInflows - cashOutflows;
            cashFlow.put("Net Cash Flow from Operations", netCashFlow);
            cashFlow.put("Ending Cash Balance", initialCash + netCashFlow);
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to generate cash flow statement", e);
        }
        return cashFlow;
    }

    public Map<String, Double> generateBalanceSheet(String startDate, String endDate) throws DatabaseException {
        Map<String, Double> balanceSheet = new LinkedHashMap<>();
        try (Connection conn = dataSource.getConnection()) {
            double cash = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(CASE WHEN type = 'IN' THEN amount ELSE -amount END) as balance " +
                "FROM CashTransactions " +
                "WHERE date <= ?")) {
                stmt.setString(1, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) cash = rs.getDouble("balance");
            }
            balanceSheet.put("Cash", cash);

            double accountsReceivable = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT COALESCE(SUM(d.amount), 0) - COALESCE(SUM(c.amount), 0) as ar " +
                "FROM Customers cu " +
                "LEFT JOIN CustomerDebits d ON cu.id = d.customerId AND d.date <= ? " +
                "LEFT JOIN CustomerCredits c ON cu.id = c.customerId AND c.date <= ?")) {
                stmt.setString(1, endDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) accountsReceivable = rs.getDouble("ar");
            }
            balanceSheet.put("Accounts Receivable", accountsReceivable);

            double inventoryValue = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(i.quantity * p.costPrice) as inventoryValue " +
                "FROM Inventory i " +
                "JOIN Products p ON i.productId = p.id")) {
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) inventoryValue = rs.getDouble("inventoryValue");
            }
            balanceSheet.put("Inventory", inventoryValue);

            double totalAssets = cash + accountsReceivable + inventoryValue;
            balanceSheet.put("Total Assets", totalAssets);

            double accountsPayable = 0.0; // Simplified; assumes no supplier credits
            balanceSheet.put("Accounts Payable", accountsPayable);

            double equity = totalAssets - accountsPayable;
            balanceSheet.put("Equity", equity);
            balanceSheet.put("Total Liabilities and Equity", totalAssets);
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to generate balance sheet", e);
        }
        return balanceSheet;
    }

    public Map<String, Double> generateProfitLossStatement(String startDate, String endDate) throws DatabaseException {
        Map<String, Double> profitLoss = new LinkedHashMap<>();
        try (Connection conn = dataSource.getConnection()) {
            double revenue = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(li.totalPrice) as revenue " +
                "FROM Invoices i " +
                "JOIN InvoiceLineItems li ON i.id = li.invoiceId " +
                "WHERE i.type = 'SALE' AND i.date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) revenue = rs.getDouble("revenue");
            }
            profitLoss.put("Revenue", revenue);

            double cogs = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(li.totalCost) as cogs " +
                "FROM Invoices i " +
                "JOIN InvoiceLineItems li ON i.id = li.invoiceId " +
                "WHERE i.type = 'SALE' AND i.date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) cogs = rs.getDouble("cogs");
            }
            profitLoss.put("Cost of Goods Sold", cogs);

            double grossProfit = revenue - cogs;
            profitLoss.put("Gross Profit", grossProfit);

            double operatingExpenses = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(amount) as expenses " +
                "FROM CashTransactions " +
                "WHERE type = 'OUT' AND category NOT IN ('COGS', 'Sales Returns', 'Inventory Adjustment', 'Taxes', 'Other Payments') AND date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) operatingExpenses = rs.getDouble("expenses");
            }
            profitLoss.put("Operating Expenses", operatingExpenses);

            double operatingIncome = grossProfit - operatingExpenses;
            profitLoss.put("Operating Income", operatingIncome);

            double taxes = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(amount) as taxes " +
                "FROM CashTransactions " +
                "WHERE type = 'OUT' AND category = 'Taxes' AND date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) taxes = rs.getDouble("taxes");
            }
            profitLoss.put("Taxes", taxes);

            double netIncome = operatingIncome - taxes;
            profitLoss.put("Net Income", netIncome);
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to generate profit and loss statement", e);
        }
        return profitLoss;
    }

    public void logInvoiceChange(String invoiceId, String changeDescription, String changedBy) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO InvoiceHistory (invoiceId, changeDescription, changedBy, changeDate) VALUES (?, ?, ?, NOW())")) {
            stmt.setString(1, invoiceId);
            stmt.setString(2, changeDescription);
            stmt.setString(3, changedBy);
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to log invoice change for: " + invoiceId, e);
        }
    }

    public List<String> getInvoiceHistory(String invoiceId) throws DatabaseException {
        List<String> history = new ArrayList<>();
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT changeDescription, changedBy, changeDate FROM InvoiceHistory WHERE invoiceId = ? ORDER BY changeDate DESC")) {
            stmt.setString(1, invoiceId);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                StringBuilder entry = new StringBuilder();
                entry.append("Date: ").append(rs.getString("changeDate"))
                     .append(", By: ").append(rs.getString("changedBy"))
                     .append(", Change: ").append(rs.getString("changeDescription"));
                history.add(entry.toString());
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get invoice history for: " + invoiceId, e);
        }
        return history;
    }

    public List<AuditEntry> getAuditLogs(int pageNumber, int pageSize) throws DatabaseException {
        List<AuditEntry> logs = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT user, tableName, recordId, action, oldValue, newValue, timestamp FROM AuditLog ORDER BY timestamp DESC LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                logs.add(new AuditEntry(
                    rs.getString("timestamp"),
                    rs.getString("user"),
                    rs.getString("tableName"),
                    rs.getString("recordId"),
                    rs.getString("action"),
                    rs.getString("oldValue"),
                    rs.getString("newValue")
                ));
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get audit logs", e);
        }
        return logs;
    }

    public int getAuditLogCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM AuditLog")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get audit log count", e);
        }
    }

    public void saveInvoiceTemplate(InvoiceTemplate template) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO InvoiceTemplates (name, invoiceType, customerId, date, paymentTerms, templateStyle, brandingColors, brandingFont) VALUES (?, ?, ?, ?, ?, ?, ?, ?) " +
                 "ON DUPLICATE KEY UPDATE invoiceType = ?, customerId = ?, date = ?, paymentTerms = ?, templateStyle = ?, brandingColors = ?, brandingFont = ?")) {
            stmt.setString(1, template.getTemplateName());
            stmt.setString(2, template.getInvoiceType());
            stmt.setObject(3, template.getCustomerId(), Types.INTEGER);
            stmt.setString(4, template.getDate());
            stmt.setString(5, template.getDefaultTerms());
            stmt.setString(6, objectMapper.writeValueAsString(template.getTemplateStyle()));
            stmt.setString(7, objectMapper.writeValueAsString(template.getBrandingColors()));
            stmt.setString(8, template.getBrandingFont());
            stmt.setString(9, template.getInvoiceType());
            stmt.setObject(10, template.getCustomerId(), Types.INTEGER);
            stmt.setString(11, template.getDate());
            stmt.setString(12, template.getDefaultTerms());
            stmt.setString(13, objectMapper.writeValueAsString(template.getTemplateStyle()));
            stmt.setString(14, objectMapper.writeValueAsString(template.getBrandingColors()));
            stmt.setString(15, template.getBrandingFont());
            stmt.executeUpdate();

            try (PreparedStatement deleteStmt = conn.prepareStatement("DELETE FROM InvoiceTemplateItems WHERE templateName = ?")) {
                deleteStmt.setString(1, template.getTemplateName());
                deleteStmt.executeUpdate();
            }

            try (PreparedStatement itemStmt = conn.prepareStatement(
                 "INSERT INTO InvoiceTemplateItems (templateName, productId, warehouseId, quantity, unit, unitPrice, totalPrice, unitCost, totalCost, discount, fixedDiscount, taxRate, totalTax, currency) " +
                 "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")) {
                for (InvoiceLineItem item : template.getDefaultItems()) {
                    itemStmt.setString(1, template.getTemplateName());
                    itemStmt.setInt(2, item.getProductId());
                    itemStmt.setInt(3, item.getWarehouseId());
                    itemStmt.setInt(4, item.getQuantity());
                    itemStmt.setString(5, item.getUnit());
                    itemStmt.setDouble(6, item.getUnitPrice());
                    itemStmt.setDouble(7, item.getTotalPrice());
                    itemStmt.setDouble(8, item.getUnitCost());
                    itemStmt.setDouble(9, item.getTotalCost());
                    itemStmt.setDouble(10, item.getDiscount());
                    itemStmt.setDouble(11, item.getFixedDiscount());
                    itemStmt.setDouble(12, item.getTaxRate());
                    itemStmt.setDouble(13, item.getTotalTax());
                    itemStmt.setString(14, item.getCurrency());
                    itemStmt.addBatch();
                }
                itemStmt.executeBatch();
            }
        } catch (SQLException | com.fasterxml.jackson.core.JsonProcessingException e) {
            throw new DataProcessingException("Failed to save invoice template: " + template.getTemplateName(), e);
        }
    }

    public InvoiceTemplate loadInvoiceTemplate(String templateName) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT * FROM InvoiceTemplates WHERE name = ?")) {
            stmt.setString(1, templateName);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                InvoiceTemplate template = new InvoiceTemplate();
                template.setTemplateName(rs.getString("name"));
                template.setInvoiceType(rs.getString("invoiceType"));
                template.setCustomerId(rs.getObject("customerId", Integer.class));
                template.setDate(rs.getString("date"));
                template.setDefaultTerms(rs.getString("paymentTerms"));
                String styleJson = rs.getString("templateStyle");
                if (styleJson != null) {
                    template.setTemplateStyle(objectMapper.readValue(styleJson, Map.class));
                }
                String colorsJson = rs.getString("brandingColors");
                if (colorsJson != null) {
                    template.setBrandingColors(objectMapper.readValue(colorsJson, Map.class));
                }
                template.setBrandingFont(rs.getString("brandingFont"));

                try (PreparedStatement itemStmt = conn.prepareStatement(
                     "SELECT * FROM InvoiceTemplateItems WHERE templateName = ?")) {
                    itemStmt.setString(1, templateName);
                    ResultSet itemRs = itemStmt.executeQuery();
                    List<InvoiceLineItem> items = new ArrayList<>();
                    while (itemRs.next()) {
                        items.add(new InvoiceLineItem(
                            0, itemRs.getInt("productId"), itemRs.getInt("warehouseId"),
                            itemRs.getInt("quantity"), itemRs.getString("unit"),
                            itemRs.getDouble("unitPrice"), itemRs.getDouble("totalPrice"),
                            itemRs.getDouble("unitCost"), itemRs.getDouble("totalCost"),
                            itemRs.getDouble("discount"), itemRs.getDouble("fixedDiscount"),
                            itemRs.getDouble("taxRate"), itemRs.getDouble("totalTax"),
                            itemRs.getString("currency")
                        ));
                    }
                    template.setDefaultItems(items);
                }
                return template;
            }
            return null;
        } catch (SQLException | com.fasterxml.jackson.core.JsonProcessingException e) {
            throw new DataProcessingException("Failed to load invoice template: " + templateName, e);
        }
    }

    public String[] getInvoiceTemplateNames() throws DatabaseException {
        List<String> names = new ArrayList<>();
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT name FROM InvoiceTemplates")) {
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) names.add(rs.getString("name"));
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get invoice template names", e);
        }
        return names.toArray(new String[0]);
    }

    public String getTypicalPaymentTerms(int customerId) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT paymentTerm FROM Invoices WHERE customerId = ? ORDER BY date DESC LIMIT 1")) {
            stmt.setInt(1, customerId);
            ResultSet rs = stmt.executeQuery();
            return rs.next() ? rs.getString("paymentTerm") : null;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get typical payment terms for customer: " + customerId, e);
        }
    }

    public List<InvoiceDetails> getPaidInvoicesInDateRange(LocalDate startDate, LocalDate endDate) throws DatabaseException {
        List<InvoiceDetails> invoices = new ArrayList<>();
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT i.* FROM Invoices i JOIN Payments p ON i.id = p.invoiceId WHERE p.paymentDate BETWEEN ? AND ?")) {
            stmt.setString(1, startDate.toString());
            stmt.setString(2, endDate.toString());
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                invoices.add(loadInvoiceDetails(rs.getString("id")));
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get paid invoices", e);
        }
        return invoices;
    }

    public List<InvoiceDetails> getUnpaidInvoices() throws DatabaseException {
        List<InvoiceDetails> invoices = new ArrayList<>();
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT i.* FROM Invoices i LEFT JOIN Payments p ON i.id = p.invoiceId WHERE p.id IS NULL AND i.type = 'SALE'")) {
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                invoices.add(loadInvoiceDetails(rs.getString("id")));
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get unpaid invoices", e);
        }
        return invoices;
    }

    public LocalDate getPaymentDate(String invoiceId) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT paymentDate FROM Payments WHERE invoiceId = ? LIMIT 1")) {
            stmt.setString(1, invoiceId);
            ResultSet rs = stmt.executeQuery();
            return rs.next() ? LocalDate.parse(rs.getString("paymentDate").substring(0, 10)) : null;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get payment date for invoice: " + invoiceId, e);
        }
    }

    public List<Object[]> getAgingAnalysis() throws DatabaseException {
        List<Object[]> aging = new ArrayList<>();
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT i.id, i.date, i.totalAmount, c.name, DATEDIFF(CURDATE(), i.date) as daysOverdue " +
                 "FROM Invoices i JOIN Customers c ON i.customerId = c.id " +
                 "WHERE i.type = 'SALE' AND i.totalAmount > 0 AND i.deliveryStatus != 'PAID'")) {
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                aging.add(new Object[]{
                    rs.getString("id"),
                    rs.getString("name"),
                    rs.getDouble("totalAmount"),
                    rs.getInt("daysOverdue")
                });
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get aging analysis", e);
        }
        return aging;
    }

    public Map<String, Double> getSalesByCustomer(String startDate, String endDate) throws DatabaseException {
        Map<String, Double> salesByCustomer = new HashMap<>();
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT c.name, SUM(i.totalAmount) as total " +
                 "FROM Invoices i " +
                 "JOIN Customers c ON i.customerId = c.id " +
                 "WHERE i.type = 'SALE' AND i.date BETWEEN ? AND ? " +
                 "GROUP BY c.name")) {
            stmt.setString(1, startDate);
            stmt.setString(2, endDate);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                salesByCustomer.put(rs.getString("name"), rs.getDouble("total"));
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get sales by customer", e);
        }
        return salesByCustomer;
    }

    public Map<String, Double> getSalesByProduct(String startDate, String endDate) throws DatabaseException {
        Map<String, Double> salesByProduct = new HashMap<>();
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT p.name, SUM(li.totalPrice) as total " +
                 "FROM InvoiceLineItems li " +
                 "JOIN Invoices i ON li.invoiceId = i.id " +
                 "JOIN Products p ON li.productId = p.id " +
                 "WHERE i.type = 'SALE' AND i.date BETWEEN ? AND ? " +
                 "GROUP BY p.name")) {
            stmt.setString(1, startDate);
            stmt.setString(2, endDate);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                salesByProduct.put(rs.getString("name"), rs.getDouble("total"));
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get sales by product", e);
        }
        return salesByProduct;
    }

    public Map<String, Double> getTaxReport(String startDate, String endDate) throws DatabaseException {
        Map<String, Double> taxReport = new HashMap<>();
        try (Connection conn = dataSource.getConnection()) {
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(li.totalTax) as lineItemTax, SUM(i.totalTax) as invoiceTax " +
                "FROM Invoices i " +
                "JOIN InvoiceLineItems li ON i.id = li.invoiceId " +
                "WHERE i.date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) {
                    taxReport.put("Line Item Taxes", rs.getDouble("lineItemTax"));
                    taxReport.put("Invoice Taxes", rs.getDouble("invoiceTax"));
                    taxReport.put("Total Taxes", rs.getDouble("lineItemTax") + rs.getDouble("invoiceTax"));
                }
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to generate tax report", e);
        }
        return taxReport;
    }

    public InvoiceDiscussionThread getDiscussionThread(String invoiceId) throws DatabaseException {
        InvoiceDiscussionThread thread = new InvoiceDiscussionThread(invoiceId);
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT user, commentText, timestamp FROM InvoiceComments WHERE invoiceId = ? ORDER BY timestamp")) {
            stmt.setString(1, invoiceId);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                thread.addComment(rs.getString("user"), rs.getString("commentText"));
            }
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to load discussion thread for: " + invoiceId, e);
        }
        return thread;
    }

    public void saveDiscussionThread(InvoiceDiscussionThread thread) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO InvoiceComments (invoiceId, user, commentText, timestamp) VALUES (?, ?, ?, ?)")) {
            for (InvoiceComment comment : thread.getCommentHistory()) {
                stmt.setString(1, thread.getInvoiceId());
                stmt.setString(2, comment.getUser());
                stmt.setString(3, comment.getCommentText());
                stmt.setString(4, comment.getTimestamp().toString());
                stmt.addBatch();
            }
            stmt.executeBatch();
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to save discussion thread for: " + thread.getInvoiceId(), e);
        }
    }

    public void requestPaymentPlan(String invoiceId, int installments, String user) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO PaymentPlanRequests (invoiceId, installments, requestedBy, requestDate) VALUES (?, ?, ?, NOW())")) {
            stmt.setString(1, invoiceId);
            stmt.setInt(2, installments);
            stmt.setString(3, user);
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to request payment plan for invoice: " + invoiceId, e);
        }
    }

    public List<InvoiceDetails> searchInvoices(String query) throws DatabaseException {
        NaturalLanguageParser parser = new NaturalLanguageParser();
        Map<String, String> conditions = parser.parseInvoiceQuery(query);
        StringBuilder sql = new StringBuilder("SELECT * FROM Invoices WHERE 1=1");
        List<Object> params = new ArrayList<>();

        if (conditions.containsKey("unpaid")) {
            sql.append(" AND NOT EXISTS (SELECT 1 FROM Payments p WHERE p.invoiceId = Invoices.id)");
        }
        if (conditions.containsKey("customer")) {
            sql.append(" AND customerId = (SELECT id FROM Customers WHERE name = ? LIMIT 1)");
            params.add(conditions.get("customer"));
        }
        if (conditions.containsKey("year")) {
            sql.append(" AND YEAR(date) = ?");
            params.add(Integer.parseInt(conditions.get("year")));
        }
        if (conditions.containsKey("month")) {
            sql.append(" AND MONTH(date) = ?");
            params.add(getMonthNumber(conditions.get("month")));
        }
        if (conditions.containsKey("status")) {
            sql.append(" AND deliveryStatus = ?");
            params.add(conditions.get("status"));
        }
        if (conditions.containsKey("startDate")) {
            sql.append(" AND date >= ?");
            params.add(conditions.get("startDate"));
        }
        if (conditions.containsKey("endDate")) {
            sql.append(" AND date <= ?");
            params.add(conditions.get("endDate"));
        }
        if (conditions.containsKey("totalSales")) {
            sql.append(" AND type = 'SALE'");
        }

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql.toString())) {
            for (int i = 0; i < params.size(); i++) {
                stmt.setObject(i + 1, params.get(i));
            }
            ResultSet rs = stmt.executeQuery();
            List<InvoiceDetails> results = new ArrayList<>();
            while (rs.next()) {
                results.add(loadInvoiceDetails(rs.getString("id")));
            }
            return results;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to search invoices with query: " + query, e);
        }
    }

    public List<Expense> searchExpenses(String query) throws DatabaseException {
        NaturalLanguageParser parser = new NaturalLanguageParser();
        Map<String, String> conditions = parser.parseExpenseQuery(query);
        StringBuilder sql = new StringBuilder("SELECT * FROM CashTransactions WHERE type = 'OUT'");
        List<Object> params = new ArrayList<>();

        if (conditions.containsKey("category")) {
            sql.append(" AND category = ?");
            params.add(conditions.get("category"));
        }
        if (conditions.containsKey("year")) {
            sql.append(" AND YEAR(date) = ?");
            params.add(Integer.parseInt(conditions.get("year")));
        }
        if (conditions.containsKey("month")) {
            sql.append(" AND MONTH(date) = ?");
            params.add(getMonthNumber(conditions.get("month")));
        }

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql.toString())) {
            for (int i = 0; i < params.size(); i++) {
                stmt.setObject(i + 1, params.get(i));
            }
            ResultSet rs = stmt.executeQuery();
            List<Expense> results = new ArrayList<>();
            while (rs.next()) {
                results.add(new Expense(
                    rs.getString("description"),
                    rs.getDouble("amount"),
                    rs.getString("currency"),
                    rs.getString("category"),
                    rs.getString("date")
                ));
            }
            return results;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to search expenses with query: " + query, e);
        }
    }

    public List<Adjustment> searchAdjustments(String query) throws DatabaseException {
        NaturalLanguageParser parser = new NaturalLanguageParser();
        Map<String, String> conditions = parser.parseAdjustmentQuery(query);
        StringBuilder sql = new StringBuilder("SELECT * FROM Adjustments WHERE 1=1");
        List<Object> params = new ArrayList<>();

        if (conditions.containsKey("type")) {
            sql.append(" AND type = ?");
            params.add(conditions.get("type"));
        }
        if (conditions.containsKey("year")) {
            sql.append(" AND YEAR(date) = ?");
            params.add(Integer.parseInt(conditions.get("year")));
        }
        if (conditions.containsKey("month")) {
            sql.append(" AND MONTH(date) = ?");
            params.add(getMonthNumber(conditions.get("month")));
        }

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql.toString())) {
            for (int i = 0; i < params.size(); i++) {
                stmt.setObject(i + 1, params.get(i));
            }
            ResultSet rs = stmt.executeQuery();
            List<Adjustment> results = new ArrayList<>();
            while (rs.next()) {
                results.add(new Adjustment(
                    rs.getInt("id"),
                    rs.getString("type"),
                    rs.getString("description"),
                    rs.getDouble("amount"),
                    rs.getObject("accountFrom", Integer.class),
                    rs.getObject("accountTo", Integer.class),
                    rs.getString("date"),
                    rs.getString("currency"),
                    rs.getDouble("exchangeRate")
                ));
            }
            return results;
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to search adjustments with query: " + query, e);
        }
    }

    private int getMonthNumber(String monthName) {
        return switch (monthName.toLowerCase()) {
            case "january" -> 1;
            case "february" -> 2;
            case "march" -> 3;
            case "april" -> 4;
            case "may" -> 5;
            case "june" -> 6;
            case "july" -> 7;
            case "august" -> 8;
            case "september" -> 9;
            case "october" -> 10;
            case "november" -> 11;
            case "december" -> 12;
            default -> throw new IllegalArgumentException("Invalid month: " + monthName);
        };
    }

    public void updateExchangeRate(String currencyFrom, String currencyTo, double rate) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO ExchangeRates (currencyFrom, currencyTo, rate, lastUpdated) VALUES (?, ?, ?, NOW()) " +
                 "ON DUPLICATE KEY UPDATE rate = ?, lastUpdated = NOW()")) {
            stmt.setString(1, currencyFrom);
            stmt.setString(2, currencyTo);
            stmt.setDouble(3, rate);
            stmt.setDouble(4, rate);
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to update exchange rate for " + currencyFrom + " to " + currencyTo, e);
        }
    }

    public double getExchangeRate(String currencyFrom, String currencyTo) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT rate FROM ExchangeRates WHERE currencyFrom = ? AND currencyTo = ?")) {
            stmt.setString(1, currencyFrom);
            stmt.setString(2, currencyTo);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getDouble("rate");
            return 1.0; // Default to 1 if no rate found
        } catch (SQLException e) {
            throw new DataProcessingException("Failed to get exchange rate for " + currencyFrom + " to " + currencyTo, e);
        }
    }

    public void close() {
        if (dataSource != null && !dataSource.isClosed()) dataSource.close();
    }

    static class Product {
        private final String name;
        private final double sellingPrice;
        private final double costPrice;
        private final String unit;

        Product(String name, double sellingPrice, double costPrice, String unit) {
            this.name = name;
            this.sellingPrice = sellingPrice;
            this.costPrice = costPrice;
            this.unit = unit;
        }

        public String getName() { return name; }
        public double getSellingPrice() { return sellingPrice; }
        public double getCostPrice() { return costPrice; }
        public String getUnit() { return unit; }
    }
}

//================================================ 9 =========  AuditService.java  =================================================================================

package com.example.financial;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class AuditService {
    private static final Logger LOGGER = LoggerFactory.getLogger(AuditService.class);
    private final DatabaseService dbService;

    public AuditService(DatabaseService dbService) {
        this.dbService = dbService;
    }

    public void logAction(String user, String tableName, String recordId, String action, String oldValue, String newValue) {
        try (Connection conn = DatabaseService.dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO AuditLog (user, tableName, recordId, action, oldValue, newValue, timestamp) VALUES (?, ?, ?, ?, ?, ?, NOW())")) {
            stmt.setString(1, user);
            stmt.setString(2, tableName);
            stmt.setString(3, recordId);
            stmt.setString(4, action);
            stmt.setString(5, oldValue);
            stmt.setString(6, newValue);
            stmt.executeUpdate();
            LOGGER.info("Audit log entry created: {} by {} on {} (ID: {})", action, user, tableName, recordId);
        } catch (SQLException e) {
            LOGGER.error("Failed to log audit action", e);
        }
    }
}

//================================================================== 22. ExchangeRateService.java ============================================================================

package com.example.financial;

public class ExchangeRateService {
    public double getExchangeRate(String fromCurrency, String toCurrency) throws DatabaseException {
        // Simplified mock implementation; in reality, fetch from DB or API
        if (fromCurrency.equals(toCurrency)) return 1.0;
        if (fromCurrency.equals("USD") && toCurrency.equals("IQD")) return 1310.0;
        if (fromCurrency.equals("IQD") && toCurrency.equals("USD")) return 1.0 / 1310.0;
        if (fromCurrency.equals("USD") && toCurrency.equals("RMB")) return 7.0;
        if (fromCurrency.equals("RMB") && toCurrency.equals("USD")) return 1.0 / 7.0;
        return 1.0; // Default fallback
    }

    public void updateExchangeRates() {
        // Mock implementation; real version would fetch from an API or DB
        System.out.println("Exchange rates updated (mock)");
    }
}

//================================================== 2 ================= InvoiceDetails.java =============================================

package com.example.financial;

import java.util.List;
import java.util.Map;

public class InvoiceDetails {
    private final String invoiceId;
    private final String invoiceType;
    private final String customerName;
    private final String supplierName;
    private final String date;
    private final double totalAmount;
    private final double totalDebit;
    private final double totalCredit;
    private final String currency;
    private final String paymentTerm;
    private final String status;
    private final String paymentInstructions;
    private final String notes;
    private final List<InvoiceLineItem> lineItems;
    private final double usdTotalAmount;
    private final double localTotalAmount;
    private final double totalTax;
    private final double invoiceDiscount;
    private final double invoiceFixedDiscount;
    private final double invoiceTaxRate;
    private final double shippingCharge;
    private final String logoPath;
    private final double exchangeRate;
    private final Map<String, String> customFields;

    public InvoiceDetails(String invoiceId, String invoiceType, String customerName, String supplierName, String date, 
                          double totalAmount, double totalDebit, double totalCredit, String currency, String paymentTerm, 
                          String status, String paymentInstructions, String notes, List<InvoiceLineItem> lineItems, 
                          double usdTotalAmount, double localTotalAmount, double totalTax, double invoiceDiscount, 
                          double invoiceFixedDiscount, double invoiceTaxRate, double shippingCharge, String logoPath, 
                          double exchangeRate, Map<String, String> customFields) {
        this.invoiceId = invoiceId;
        this.invoiceType = invoiceType;
        this.customerName = customerName;
        this.supplierName = supplierName;
        this.date = date;
        this.totalAmount = totalAmount;
        this.totalDebit = totalDebit;
        this.totalCredit = totalCredit;
        this.currency = currency;
        this.paymentTerm = paymentTerm;
        this.status = status;
        this.paymentInstructions = paymentInstructions;
        this.notes = notes;
        this.lineItems = lineItems;
        this.usdTotalAmount = usdTotalAmount;
        this.localTotalAmount = localTotalAmount;
        this.totalTax = totalTax;
        this.invoiceDiscount = invoiceDiscount;
        this.invoiceFixedDiscount = invoiceFixedDiscount;
        this.invoiceTaxRate = invoiceTaxRate;
        this.shippingCharge = shippingCharge;
        this.logoPath = logoPath;
        this.exchangeRate = exchangeRate;
        this.customFields = customFields;
    }

    public String getInvoiceId() { return invoiceId; }
    public String getInvoiceType() { return invoiceType; }
    public String getCustomerName() { return customerName; }
    public String getSupplierName() { return supplierName; }
    public String getDate() { return date; }
    public double getTotalAmount() { return totalAmount; }
    public double getTotalDebit() { return totalDebit; }
    public double getTotalCredit() { return totalCredit; }
    public String getCurrency() { return currency; }
    public String getPaymentTerm() { return paymentTerm; }
    public String getStatus() { return status; }
    public String getPaymentInstructions() { return paymentInstructions; }
    public String getNotes() { return notes; }
    public List<InvoiceLineItem> getLineItems() { return lineItems; }
    public double getUsdTotalAmount() { return usdTotalAmount; }
    public double getLocalTotalAmount() { return localTotalAmount; }
    public double getTotalTax() { return totalTax; }
    public double getInvoiceDiscount() { return invoiceDiscount; }
    public double getInvoiceFixedDiscount() { return invoiceFixedDiscount; }
    public double getInvoiceTaxRate() { return invoiceTaxRate; }
    public double getShippingCharge() { return shippingCharge; }
    public String getLogoPath() { return logoPath; }
    public double getExchangeRate() { return exchangeRate; }
    public Map<String, String> getCustomFields() { return customFields; }

    @Override
    public String toString() {
        return "Invoice #" + invoiceId + " (" + invoiceType + ") - " + customerName + " - " + totalAmount + " " + currency;
    }
}

//=============================================================== 3 ======================  InvoiceLineItem.java ===============================================

package com.example.financial;

public class InvoiceLineItem {
    private final int id;
    private final int productId;
    private final int warehouseId;
    private final int quantity;
    private final String unit;
    private final double unitPrice;
    private final double totalPrice;
    private final double unitCost;
    private final double totalCost;
    private final double discount;
    private final double fixedDiscount;
    private final double taxRate;
    private final double totalTax;
    private final String currency;

    public InvoiceLineItem(int id, int productId, int warehouseId, int quantity, String unit, double unitPrice, 
                           double totalPrice, double unitCost, double totalCost, double discount, double fixedDiscount, 
                           double taxRate, double totalTax, String currency) {
        this.id = id;
        this.productId = productId;
        this.warehouseId = warehouseId;
        this.quantity = quantity;
        this.unit = unit;
        this.unitPrice = unitPrice;
        this.totalPrice = totalPrice;
        this.unitCost = unitCost;
        this.totalCost = totalCost;
        this.discount = discount;
        this.fixedDiscount = fixedDiscount;
        this.taxRate = taxRate;
        this.totalTax = totalTax;
        this.currency = currency;
    }

    public int getId() { return id; }
    public int getProductId() { return productId; }
    public int getWarehouseId() { return warehouseId; }
    public int getQuantity() { return quantity; }
    public String getUnit() { return unit; }
    public double getUnitPrice() { return unitPrice; }
    public double getTotalPrice() { return totalPrice; }
    public double getUnitCost() { return unitCost; }
    public double getTotalCost() { return totalCost; }
    public double getDiscount() { return discount; }
    public double getFixedDiscount() { return fixedDiscount; }
    public double getTaxRate() { return taxRate; }
    public double getTotalTax() { return totalTax; }
    public String getCurrency() { return currency; }

    @Override
    public String toString() {
        return "Product ID: " + productId + ", Quantity: " + quantity + " " + unit + ", Total: " + totalPrice + " " + currency;
    }
}
//========================================================== 4 =========== InvoiceTemplate.java ============================================

package com.example.financial;

import java.util.List;
import java.util.Map;

public class InvoiceTemplate {
    private String templateName;
    private String invoiceType;
    private Integer customerId;
    private String date;
    private String defaultTerms;
    private Map<String, Object> templateStyle;
    private Map<String, String> brandingColors;
    private String brandingFont;
    private List<InvoiceLineItem> defaultItems;

    public InvoiceTemplate() {}

    public String getTemplateName() { return templateName; }
    public void setTemplateName(String templateName) { this.templateName = templateName; }
    public String getInvoiceType() { return invoiceType; }
    public void setInvoiceType(String invoiceType) { this.invoiceType = invoiceType; }
    public Integer getCustomerId() { return customerId; }
    public void setCustomerId(Integer customerId) { this.customerId = customerId; }
    public String getDate() { return date; }
    public void setDate(String date) { this.date = date; }
    public String getDefaultTerms() { return defaultTerms; }
    public void setDefaultTerms(String defaultTerms) { this.defaultTerms = defaultTerms; }
    public Map<String, Object> getTemplateStyle() { return templateStyle; }
    public void setTemplateStyle(Map<String, Object> templateStyle) { this.templateStyle = templateStyle; }
    public Map<String, String> getBrandingColors() { return brandingColors; }
    public void setBrandingColors(Map<String, String> brandingColors) { this.brandingColors = brandingColors; }
    public String getBrandingFont() { return brandingFont; }
    public void setBrandingFont(String brandingFont) { this.brandingFont = brandingFont; }
    public List<InvoiceLineItem> getDefaultItems() { return defaultItems; }
    public void setDefaultItems(List<InvoiceLineItem> defaultItems) { this.defaultItems = defaultItems; }

    @Override
    public String toString() {
        return "Template: " + templateName + " (" + invoiceType + ")";
    }
}

//======================================================== 8 ================= AsyncInvoicePdfService.java ============================================
package com.example.financial;

import com.itextpdf.text.Document;
import com.itextpdf.text.Paragraph;
import com.itextpdf.text.pdf.PdfWriter;

import java.io.FileOutputStream;

public class AsyncInvoicePdfService {
    private final InvoiceDetails invoice;

    public AsyncInvoicePdfService(InvoiceDetails invoice) {
        this.invoice = invoice;
    }

    public void exportToPdf() throws Exception {
        Document document = new Document();
        PdfWriter.getInstance(document, new FileOutputStream("Invoice_" + invoice.getInvoiceId() + ".pdf"));
        document.open();
        document.add(new Paragraph("Invoice #" + invoice.getInvoiceId()));
        document.add(new Paragraph("Customer: " + invoice.getCustomerName()));
        document.add(new Paragraph("Date: " + invoice.getDate()));
        document.add(new Paragraph("Total: " + invoice.getTotalAmount() + " " + invoice.getCurrency()));
        document.close();
    }

    public void printInvoice() throws Exception {
        exportToPdf(); // Simplified; real printing would use a printer API
        System.out.println("Printing invoice #" + invoice.getInvoiceId());
    }
}

//=============================================10 ============= ErrorHandler.java =======================================================

package com.example.financial;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ErrorHandler {
    private static final Logger LOGGER = LoggerFactory.getLogger(ErrorHandler.class);

    public static void handleException(Throwable e, String message, javafx.scene.Node context) {
        LOGGER.error(message, e);
        javafx.application.Platform.runLater(() -> 
            new Alert(Alert.AlertType.ERROR, message + ": " + e.getMessage()).showAndWait());
    }

    public static void validateRequiredField(String value, String fieldName) throws ValidationException {
        if (value == null || value.trim().isEmpty()) {
            throw new ValidationException(fieldName + " is required");
        }
    }

    public static boolean validateStringSafe(String value, String fieldName) {
        try {
            validateRequiredField(value, fieldName);
            return true;
        } catch (ValidationException e) {
            LOGGER.warn(e.getMessage());
            return false;
        }
    }

    public static double validatePositiveDouble(String value, String fieldName, double min, double max) throws ValidationException {
        validateRequiredField(value, fieldName);
        try {
            double result = Double.parseDouble(value);
            if (result < min || result > max) {
                throw new ValidationException(fieldName + " must be between " + min + " and " + max);
            }
            return result;
        } catch (NumberFormatException e) {
            throw new ValidationException(fieldName + " must be a valid number");
        }
    }
}

//============================================================  NaturalLanguageParser.java: ============================================================

package com.example.financial;

import java.util.HashMap;
import java.util.Map;

public class NaturalLanguageParser {
    public Map<String, String> parseInvoiceQuery(String query) {
        Map<String, String> conditions = new HashMap<>();
        String[] tokens = query.toLowerCase().split("\\s+");
        for (int i = 0; i < tokens.length; i++) {
            switch (tokens[i]) {
                case "unpaid": conditions.put("unpaid", "true"); break;
                case "customer": if (i + 1 < tokens.length) conditions.put("customer", tokens[++i]); break;
                case "year": if (i + 1 < tokens.length) conditions.put("year", tokens[++i]); break;
                case "month": if (i + 1 < tokens.length) conditions.put("month", tokens[++i]); break;
                case "status": if (i + 1 < tokens.length) conditions.put("status", tokens[++i].toUpperCase()); break;
                case "start": if (i + 1 < tokens.length) conditions.put("startDate", tokens[++i]); break;
                case "end": if (i + 1 < tokens.length) conditions.put("endDate", tokens[++i]); break;
                case "sales": conditions.put("totalSales", "true"); break;
            }
        }
        return conditions;
    }

    public Map<String, String> parseExpenseQuery(String query) {
        Map<String, String> conditions = new HashMap<>();
        String[] tokens = query.toLowerCase().split("\\s+");
        for (int i = 0; i < tokens.length; i++) {
            switch (tokens[i]) {
                case "category": if (i + 1 < tokens.length) conditions.put("category", tokens[++i]); break;
                case "year": if (i + 1 < tokens.length) conditions.put("year", tokens[++i]); break;
                case "month": if (i + 1 < tokens.length) conditions.put("month", tokens[++i]); break;
            }
        }
        return conditions;
    }

    public Map<String, String> parseAdjustmentQuery(String query) {
        Map<String, String> conditions = new HashMap<>();
        String[] tokens = query.toLowerCase().split("\\s+");
        for (int i = 0; i < tokens.length; i++) {
            switch (tokens[i]) {
                case "type": if (i + 1 < tokens.length) conditions.put("type", tokens[++i].toUpperCase()); break;
                case "year": if (i + 1 < tokens.length) conditions.put("year", tokens[++i]); break;
                case "month": if (i + 1 < tokens.length) conditions.put("month", tokens[++i]); break;
            }
        }
        return conditions;
    }
}
//=============================================== DatabaseException.java: =================================================================================

package com.example.financial;

public class DataProcessingException extends DatabaseException {
    public DataProcessingException(String message, Throwable cause) {
        super(message, cause);
    }
}


//===================================================  DataProcessingException.java: ==========================================

package com.example.financial;

public class DataProcessingException extends DatabaseException {
    public DataProcessingException(String message, Throwable cause) {
        super(message, cause);
    }
}


//==================================================  ValidationException.java: ==================================================

package com.example.financial;

public class ValidationException extends Exception {
    public ValidationException(String message) {
        super(message);
    }
}

//============================================ 7 ========  InvoiceDiscussionThread.java  =====================================================================

package com.example.financial;

import java.util.ArrayList;
import java.util.List;

public class InvoiceDiscussionThread {
    private final String invoiceId;
    private final List<InvoiceComment> commentHistory;

    public InvoiceDiscussionThread(String invoiceId) {
        this.invoiceId = invoiceId;
        this.commentHistory = new ArrayList<>();
    }

    public String getInvoiceId() {
        return invoiceId;
    }

    public List<InvoiceComment> getCommentHistory() {
        return commentHistory;
    }

    public void addComment(String user, String commentText) {
        commentHistory.add(new InvoiceComment(user, commentText));
    }

    public void addComment(InvoiceComment comment) {
        commentHistory.add(comment);
    }

    @Override
    public String toString() {
        return "Discussion for Invoice #" + invoiceId + " (" + commentHistory.size() + " comments)";
    }
}

//=================src/main/java/com/example/financial/InvoiceComment.java ===============


package com.example.financial;

import java.time.LocalDateTime;

public class InvoiceComment {
    private final String user;
    private final String commentText;
    private final LocalDateTime timestamp;

    public InvoiceComment(String user, String commentText) {
        this.user = user;
        this.commentText = commentText;
        this.timestamp = LocalDateTime.now();
    }

    public InvoiceComment(String user, String commentText, LocalDateTime timestamp) {
        this.user = user;
        this.commentText = commentText;
        this.timestamp = timestamp;
    }

    public String getUser() {
        return user;
    }

    public String getCommentText() {
        return commentText;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    @Override
    public String toString() {
        return timestamp + " - " + user + ": " + commentText;
    }
}

//============================= src/main/java/com/example/financial/Contact.java ==========



package com.example.financial;

public class Contact {
    private final int id;
    private final String name;
    private final String contact;
    private final String email;
    private final String address;

    public Contact(int id, String name, String contact, String email, String address) {
        this.id = id;
        this.name = name;
        this.contact = contact;
        this.email = email;
        this.address = address;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getContact() {
        return contact;
    }

    public String getEmail() {
        return email;
    }

    public String getAddress() {
        return address;
    }

    @Override
    public String toString() {
        return id + " - " + name;
    }
}



//========================================src/main/java/com/example/financial/InventoryItem.java =========



package com.example.financial;

public class InventoryItem {
    private final int productId;
    private final int warehouseId;
    private final int quantity;

    public InventoryItem(int productId, int warehouseId, int quantity) {
        this.productId = productId;
        this.warehouseId = warehouseId;
        this.quantity = quantity;
    }

    public int getProductId() {
        return productId;
    }

    public int getWarehouseId() {
        return warehouseId;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "Product ID: " + productId + ", Warehouse ID: " + warehouseId + ", Quantity: " + quantity;
    }
}



//====================  src/main/java/com/example/financial/Attachment.java  =============



package com.example.financial;

public class Attachment {
    private final int id;
    private final String fileName;
    private final long fileSize;
    private final String uploadDate;

    public Attachment(int id, String fileName, long fileSize, String uploadDate) {
        this.id = id;
        this.fileName = fileName;
        this.fileSize = fileSize;
        this.uploadDate = uploadDate;
    }

    public int getId() {
        return id;
    }

    public String getFileName() {
        return fileName;
    }

    public long getFileSize() {
        return fileSize;
    }

    public String getUploadDate() {
        return uploadDate;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", File: " + fileName + ", Size: " + fileSize + " bytes, Uploaded: " + uploadDate;
    }
}



//======================= src/main/java/com/example/financial/Expense.java ===============



package com.example.financial;

public class Expense {
    private final String description;
    private final double amount;
    private final String currency;
    private final String category;
    private final String date;

    public Expense(String description, double amount, String currency, String category, String date) {
        this.description = description;
        this.amount = amount;
        this.currency = currency;
        this.category = category;
        this.date = date;
    }

    public String getDescription() {
        return description;
    }

    public double getAmount() {
        return amount;
    }

    public String getCurrency() {
        return currency;
    }

    public String getCategory() {
        return category;
    }

    public String getDate() {
        return date;
    }

    @Override
    public String toString() {
        return description + " - " + amount + " " + currency + " (" + category + ") on " + date;
    }
}


//======================================= src/main/java/com/example/financial/Adjustment.java  ============



package com.example.financial;

public class Adjustment {
    private final int id;
    private final String type;
    private final String description;
    private final double amount;
    private final Integer accountFrom;
    private final Integer accountTo;
    private final String date;
    private final String currency;
    private final double exchangeRate;

    public Adjustment(int id, String type, String description, double amount, Integer accountFrom, Integer accountTo, String date, String currency, double exchangeRate) {
        this.id = id;
        this.type = type;
        this.description = description;
        this.amount = amount;
        this.accountFrom = accountFrom;
        this.accountTo = accountTo;
        this.date = date;
        this.currency = currency;
        this.exchangeRate = exchangeRate;
    }

    public int getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public String getDescription() {
        return description;
    }

    public double getAmount() {
        return amount;
    }

    public Integer getAccountFrom() {
        return accountFrom;
    }

    public Integer getAccountTo() {
        return accountTo;
    }

    public String getDate() {
        return date;
    }

    public String getCurrency() {
        return currency;
    }

    public double getExchangeRate() {
        return exchangeRate;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Type: " + type + ", Description: " + description + ", Amount: " + amount + " " + currency + ", Date: " + date;
    }
}



//================================= src/main/java/com/example/financial/AuditEntry.java ============



package com.example.financial;

public class AuditEntry {
    private final String timestamp;
    private final String user;
    private final String tableName;
    private final String recordId;
    private final String action;
    private final String oldValue;
    private final String newValue;

    public AuditEntry(String timestamp, String user, String tableName, String recordId, String action, String oldValue, String newValue) {
        this.timestamp = timestamp;
        this.user = user;
        this.tableName = tableName;
        this.recordId = recordId;
        this.action = action;
        this.oldValue = oldValue;
        this.newValue = newValue;
    }

    public String getTimestamp() {
        return timestamp;
    }

    public String getUser() {
        return user;
    }

    public String getTableName() {
        return tableName;
    }

    public String getRecordId() {
        return recordId;
    }

    public String getAction() {
        return action;
    }

    public String getOldValue() {
        return oldValue;
    }

    public String getNewValue() {
        return newValue;
    }

    @Override
    public String toString() {
        return timestamp + " - " + user + ": " + action + " on " + tableName + " (ID: " + recordId + ")";
    }
}

//======================= src/main/java/com/example/financial/RecurringInvoice.java ==========

package com.example.financial;

public class RecurringInvoice {
    private final int id;
    private final String invoiceId;
    private final String frequencyType;
    private final int frequencyInterval;
    private final String nextDate;
    private final String endDate;
    private final String lastGenerated;

    public RecurringInvoice(int id, String invoiceId, String frequencyType, int frequencyInterval, String nextDate, String endDate, String lastGenerated) {
        this.id = id;
        this.invoiceId = invoiceId;
        this.frequencyType = frequencyType;
        this.frequencyInterval = frequencyInterval;
        this.nextDate = nextDate;
        this.endDate = endDate;
        this.lastGenerated = lastGenerated;
    }

    public int getId() {
        return id;
    }

    public String getInvoiceId() {
        return invoiceId;
    }

    public String getFrequencyType() {
        return frequencyType;
    }

    public int getFrequencyInterval() {
        return frequencyInterval;
    }

    public String getNextDate() {
        return nextDate;
    }

    public String getEndDate() {
        return endDate;
    }

    public String getLastGenerated() {
        return lastGenerated;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Invoice ID: " + invoiceId + ", Frequency: " + frequencyType + " every " + frequencyInterval + ", Next: " + nextDate;
    }
}



//=====================src/main/resources/styles.css
 


.root {
    -fx-font-family: "Arial";
    -fx-font-size: 14px;
}

.button {
    -fx-background-color: #4CAF50;
    -fx-text-fill: white;
    -fx-padding: 5 10;
}

.button:hover {
    -fx-background-color: #45a049;
}

.text-field {
    -fx-pref-width: 200px;
}

.table-view {
    -fx-background-color: #f4f4f4;
}

.tab-pane .tab-header-area .tab {
    -fx-background-color: #e0e0e0;
}

.tab-pane .tab:selected {
    -fx-background-color: #4CAF50;
    -fx-text-fill: white;
}



//========================= src/main/resources/messages_en.properties



title=Financial Management
dashboard=Dashboard
invoices=Invoices
recurringInvoices=Recurring Invoices
inventory=Inventory
attachments=Attachments
customersSuppliers=Customers & Suppliers
expenses=Expenses
reports=Reports
adjustments=Adjustments
auditTrail=Audit Trail
statusReady=Ready
statusProcessing=Processing...
newInvoice=New Invoice
markPaymentReceived=Mark Payment Received
database=Database
changeDatabase=Change Database
newDatabase=New Database
enterNewDbName=Enter New Database Name
dbConfigTitle=Database Configuration
dbUrl=Database URL
dbUsername=Username
dbPassword=Password
connect=Connect
dbConfigUpdated=Database configuration updated
dbCreated=Database created
errorCreatingDb=Error creating database
customerDetails=Customer Details
customer=Customer
customerName=Name
customerContact=Contact
customerEmail=Email
customerAddress=Address
invoiceDetails=Invoice Details
invoiceId=Invoice ID
invoiceType=Invoice Type
date=Date
paymentTerm=Payment Term
paymentInstructions=Payment Instructions
currency=Currency
paymentCurrency=Payment Currency
status=Status
logoPath=Logo Path
lineItems=Line Items
totals=Totals
shippingCharge=Shipping Charge
invoiceDiscount=Invoice Discount (%)
invoiceFixedDiscount=Fixed Discount
invoiceTaxRate=Invoice Tax Rate (%)
totalTax=Total Tax
totalAmount=Total Amount
customFields=Custom Fields
addCustomField=Add Custom Field
notes=Notes
recurringInvoice=Recurring Invoice
isRecurring=Is Recurring?
frequencyType=Frequency Type
frequencyInterval=Interval
nextDate=Next Date
endDate=End Date
comments=Comments
addComment=Add Comment
save=Save
addLineItem=Add Line Item
exportToPdf=Export to PDF
print=Print
loadTemplate=Load Template
saveTemplate=Save Template
uploadAttachment=Upload Attachment
batchProcess=Batch Process
importInvoices=Import Invoices
exportInvoices=Export Invoices
setReminder=Set Reminder
search=Search
statusFilter=Status
startDate=Start Date
endDate=End Date
overduePayments=Overdue Payments
overduePaymentsTitle=Overdue Payments Warning
addRecurring=Add Recurring Invoice
addInventory=Add Inventory
productId=Product ID
warehouseId=Warehouse ID
quantity=Quantity
transactionType=Transaction Type
transactionId=Transaction ID
upload=Upload
download=Download
loadAttachments=Load Attachments
addCustomer=Add Customer
addSupplier=Add Supplier
supplierName=Supplier Name
supplierContact=Supplier Contact
supplierEmail=Supplier Email
supplierAddress=Supplier Address
addExpense=Add Expense
category=Category
budgetAmount=Budget Amount
budgetStartDate=Budget Start Date
budgetEndDate=Budget End Date
setBudget=Set Budget
reportType=Report Type
generate=Generate
type=Type
description=Description
amount=Amount
accountFrom=From Account
accountTo=To Account
exchangeRate=Exchange Rate
addAdjustment=Add Adjustment



//==================================== src/main/resources/messages_ar.properties



title=إدارة المالية
dashboard=لوحة التحكم
invoices=الفواتير
recurringInvoices=الفواتير المتكررة
inventory=المخزون
attachments=المرفقات
customersSuppliers=العملاء والموردون
expenses=المصروفات
reports=التقارير
adjustments=التعديلات
auditTrail=سجل التدقيق
statusReady=جاهز
statusProcessing=جارٍ المعالجة
newInvoice=فاتورة جديدة
markPaymentReceived=تسجيل الدفع المستلم
database=قاعدة البيانات
changeDatabase=تغيير قاعدة البيانات
newDatabase=قاعدة بيانات جديدة
enterNewDbName=أدخل اسم قاعدة البيانات الجديدة
dbConfigTitle=تكوين قاعدة البيانات
dbUrl=رابط قاعدة البيانات
dbUsername=اسم المستخدم
dbPassword=كلمة المرور
connect=اتصال
dbConfigUpdated=تم تحديث تكوين قاعدة البيانات
dbCreated=تم إنشاء قاعدة البيانات
errorCreatingDb=خطأ في إنشاء قاعدة البيانات
customerDetails=تفاصيل العميل
customer=العميل
customerName=الاسم
customerContact=الاتصال
customerEmail=البريد الإلكتروني
customerAddress=العنوان
invoiceDetails=تفاصيل الفاتورة
invoiceId=معرف الفاتورة
invoiceType=نوع الفاتورة
date=التاريخ
paymentTerm=شرط الدفع
paymentInstructions=تعليمات الدفع
currency=العملة
paymentCurrency=عملة الدفع
status=الحالة
logoPath=مسار الشعار
lineItems=البنود
totals=الإجماليات
shippingCharge=رسوم الشحن
invoiceDiscount=خصم الفاتورة (%)
invoiceFixedDiscount=خصم ثابت
invoiceTaxRate=معدل ضريبة الفاتورة (%)
totalTax=إجمالي الضريبة
totalAmount=المبلغ الإجمالي
customFields=الحقول المخصصة
addCustomField=إضافة حقل مخصص
notes=ملاحظات
recurringInvoice=فاتورة متكررة
isRecurring=هل متكرر؟
frequencyType=نوع التكرار
frequencyInterval=الفاصل
nextDate=التاريخ التالي
endDate=تاريخ الانتهاء
comments=التعليقات
addComment=إضافة تعليق
save=حفظ
addLineItem=إضافة بند
exportToPdf=تصدير إلى PDF
print=طباعة
loadTemplate=تحميل قالب
saveTemplate=حفظ القالب
uploadAttachment=رفع مرفق
batchProcess=معالجة دفعية
importInvoices=استيراد الفواتير
exportInvoices=تصدير الفواتير
setReminder=تعيين تذكير
search=بحث
statusFilter=فلتر الحالة
startDate=تاريخ البدء
endDate=تاريخ الانتهاء
overduePayments=المدفوعات المتأخرة
overduePaymentsTitle=تحذير المدفوعات المتأخرة
addRecurring=إضافة فاتورة متكررة
addInventory=إضافة مخزون
productId=معرف المنتج
warehouseId=معرف المستودع
quantity=الكمية
transactionType=نوع المعاملة
transactionId=معرف المعاملة
upload=رفع
download=تنزيل
loadAttachments=تحميل المرفقات
addCustomer=إضافة عميل
addSupplier=إضافة مورد
supplierName=اسم المورد
supplierContact=اتصال المورد
supplierEmail=بريد المورد الإلكتروني
supplierAddress=عنوان المورد
addExpense=إضافة مصروف
category=الفئة
budgetAmount=مبلغ الميزانية
budgetStartDate=تاريخ بدء الميزانية
budgetEndDate=تاريخ انتهاء الميزانية
setBudget=تعيين الميزانية
reportType=نوع التقرير
generate=توليد
type=النوع
description=الوصف
amount=المبلغ
accountFrom=من الحساب
accountTo=إلى الحساب
exchangeRate=سعر الصرف
addAdjustment=إضافة تعديل


